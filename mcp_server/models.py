# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:03:04+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, confloat, constr


class APIError(BaseModel):
    StatusCode: float = Field(
        ..., description='Response HTTP status code', title='Status code'
    )
    code: float = Field(..., description='API error code', title='Code')
    details: List[float] = Field(
        ..., description='Additional error-specific information', title='Details'
    )
    duration: str = Field(..., description='Request duration', title='Duration')
    exception_fields: Optional[Dict[str, str]] = Field(
        None, description='Additional error info', title='Exception fields'
    )
    message: str = Field(
        ..., description='Message describing an error', title='Message'
    )
    more_info: str = Field(
        ..., description='URL with additional information', title='More info'
    )


class APNConfigFields(BaseModel):
    auth_key: Optional[str] = None
    auth_type: Optional[str] = None
    bundle_id: Optional[str] = None
    development: bool
    enabled: bool
    host: Optional[str] = None
    key_id: Optional[str] = None
    notification_template: str
    p12_cert: Optional[str] = None
    team_id: Optional[str] = None


class AuthType(Enum):
    certificate = 'certificate'
    token = 'token'


class APNConfigRequest(BaseModel):
    Disabled: Optional[bool] = None
    auth_key: Optional[str] = None
    auth_type: Optional[AuthType] = None
    bundle_id: Optional[str] = None
    development: Optional[bool] = None
    host: Optional[str] = None
    key_id: Optional[str] = None
    notification_template: Optional[str] = None
    p12_cert: Optional[str] = None
    team_id: Optional[str] = None


class Action(BaseModel):
    name: str
    style: Optional[str] = None
    text: str
    type: str
    value: Optional[str] = None


class ActionRequest(BaseModel):
    name: Optional[str] = None
    style: Optional[str] = None
    text: Optional[str] = None
    type: Optional[str] = None
    value: Optional[str] = None


class AgoraCall(BaseModel):
    channel: str


class AnyEvent(BaseModel):
    created_at: datetime
    type: str


class SearchBackend(Enum):
    elasticsearch = 'elasticsearch'
    postgres = 'postgres'
    disabled = 'disabled'


class Mode(Enum):
    CALLBACK_MODE_NONE = 'CALLBACK_MODE_NONE'
    CALLBACK_MODE_REST = 'CALLBACK_MODE_REST'
    CALLBACK_MODE_TWIRP = 'CALLBACK_MODE_TWIRP'


class AsyncModerationCallbackConfigRequest(BaseModel):
    mode: Optional[Mode] = None
    server_url: Optional[str] = None


class AsyncModerationConfigurationRequest(BaseModel):
    callback: Optional[AsyncModerationCallbackConfigRequest] = None
    timeout_ms: Optional[float] = None


class BlockList(BaseModel):
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    name: str = Field(..., description='Block list name', title='Name')
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )
    words: List[str] = Field(..., description='List of words to block', title='Words')


class Direction(Enum):
    asc = 'asc'
    desc = 'desc'


class CampaignSortField(BaseModel):
    field: str
    value: Any


class Automod(Enum):
    disabled = 'disabled'
    simple = 'simple'
    AI = 'AI'


class AutomodBehavior(Enum):
    flag = 'flag'
    block = 'block'


class BlocklistBehavior(Enum):
    flag = 'flag'
    block = 'block'


class ChannelConfigRequest(BaseModel):
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: Optional[List[str]] = None
    grants: Optional[Dict[str, List[str]]] = Field(None, title='Grants')
    max_message_length: Optional[confloat(le=20000.0)] = Field(
        None, description='Overrides max message length', title='Max Message Length'
    )
    quotes: Optional[bool] = Field(
        None, description='Enables message quotes', title='Quotes'
    )
    reactions: Optional[bool] = Field(
        None, description='Enables or disables reactions', title='Reactions'
    )
    replies: Optional[bool] = Field(
        None, description='Enables message replies (threads)', title='Replies'
    )
    typing_events: Optional[bool] = Field(
        None, description='Enables or disables typing events', title='Typing events'
    )
    uploads: Optional[bool] = Field(
        None, description='Enables or disables file uploads', title='Uploads'
    )
    url_enrichment: Optional[bool] = Field(
        None, description='Enables or disables URL enrichment', title='URL Enrichment'
    )


class ChannelCreatedEvent(BaseModel):
    created_at: datetime
    type: str


class ChannelExportRequest(BaseModel):
    cid: Optional[str] = None
    id: Optional[str] = Field(None, description='Channel ID', title='ID')
    messages_since: Optional[datetime] = Field(
        None, description='Date to export messages since', title='Messages since'
    )
    messages_until: Optional[datetime] = Field(
        None, description='Date to export messages until', title='Messages until'
    )
    type: Optional[str] = Field(None, description='Channel type', title='Type')


class ChannelFrozenEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    type: str


class Role(Enum):
    member = 'member'
    moderator = 'moderator'
    admin = 'admin'
    owner = 'owner'


class ChannelMutedEvent(BaseModel):
    created_at: datetime
    type: str


class ChannelStopWatchingRequest(BaseModel):
    client_id: Optional[str] = None
    connection_id: Optional[str] = None


class ChannelUnFrozenEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    type: str


class ChannelUnmutedEvent(BaseModel):
    created_at: datetime
    type: str


class PushProviderType(Enum):
    firebase = 'firebase'
    apn = 'apn'
    huawei = 'huawei'
    xiaomi = 'xiaomi'


class CheckSQSRequest(BaseModel):
    sqs_key: Optional[str] = Field(
        None, description='AWS SQS access key', title='SQS key'
    )
    sqs_secret: Optional[str] = Field(
        None, description='AWS SQS key secret', title='SQS secret'
    )
    sqs_url: Optional[str] = Field(
        None, description='AWS SQS endpoint URL', title='SQS URL'
    )


class Status(Enum):
    ok = 'ok'
    error = 'error'


class CheckSQSResponse(BaseModel):
    data: Optional[Dict[str, Any]] = Field(None, description='Error data', title='Data')
    duration: str
    error: Optional[str] = Field(None, description='Error text', title='Error')
    status: Status = Field(..., description='Validation result', title='Status')


class Command(BaseModel):
    args: str = Field(
        ...,
        description='Arguments help text, shown in commands auto-completion',
        title='Arguments',
    )
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    description: str = Field(
        ...,
        description='Description, shown in commands auto-completion',
        title='Description',
    )
    name: str = Field(..., description='Unique command name', title='Name')
    set: str = Field(
        ..., description='Set name used for grouping commands', title='Set'
    )
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )


class CommandRequest(BaseModel):
    args: Optional[str] = Field(
        None,
        description='Arguments help text, shown in commands auto-completion',
        title='Arguments',
    )
    description: Optional[str] = Field(
        None,
        description='Description, shown in commands auto-completion',
        title='Description',
    )
    name: Optional[str] = Field(None, description='Unique command name', title='Name')
    set: Optional[str] = Field(
        None, description='Set name used for grouping commands', title='Set'
    )


class CommitMessageRequest(BaseModel):
    pass


class DefaultRole(Enum):
    attendee = 'attendee'
    publisher = 'publisher'
    subscriber = 'subscriber'
    admin = 'admin'


class Config(BaseModel):
    app_certificate: str
    app_id: str
    default_role: Optional[DefaultRole] = None
    role_map: Optional[Dict[str, str]] = None


class ConfigRequest(BaseModel):
    app_certificate: str
    app_id: str
    default_role: Optional[DefaultRole] = None
    role_map: Optional[Dict[str, str]] = None


class CreateBlockListRequest(BaseModel):
    name: constr(max_length=255) = Field(
        ..., description='Block list name', title='Name'
    )
    words: List[str] = Field(..., description='List of words to block', title='Words')


class Type(Enum):
    audio = 'audio'
    video = 'video'


class CreateCommandRequest(BaseModel):
    args: Optional[constr(max_length=255)] = Field(
        None,
        description='Arguments help text, shown in commands auto-completion',
        title='Arguments',
    )
    description: constr(max_length=255) = Field(
        ...,
        description='Description, shown in commands auto-completion',
        title='Description',
    )
    name: constr(min_length=1, max_length=255) = Field(
        ..., description='Unique command name', title='Name'
    )
    set: Optional[constr(max_length=255)] = Field(
        None, description='Set name used for grouping commands', title='Set'
    )


class CreateCommandResponse(BaseModel):
    command: Optional[Command] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class PushProvider(Enum):
    firebase = 'firebase'
    apn = 'apn'
    huawei = 'huawei'
    xiaomi = 'xiaomi'


class Mode1(Enum):
    insert = 'insert'
    upsert = 'upsert'


class CreateImportRequest(BaseModel):
    mode: Optional[Mode1] = None
    path: str


class CreateImportURLRequest(BaseModel):
    filename: Optional[str] = None


class CreateImportURLResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    path: str
    upload_url: str


class CreateRoleRequest(BaseModel):
    name: constr(max_length=64) = Field(..., description='Role name', title='Name')


class DeactivateUserRequest(BaseModel):
    created_by_id: Optional[str] = Field(
        None,
        description='ID of the user who deactivated the user',
        title='Created by ID',
    )
    mark_messages_deleted: Optional[bool] = Field(
        None,
        description='Makes messages appear to be deleted',
        title='Mark messages deleted',
    )
    user_id: str = Field(..., title='User ID')


class DeactivateUsersRequest(BaseModel):
    created_by_id: Optional[str] = Field(
        None,
        description='ID of the user who deactivated the users',
        title='Created by ID',
    )
    mark_messages_deleted: Optional[bool] = Field(
        None,
        description='Makes messages appear to be deleted',
        title='Mark messages deleted',
    )
    user_ids: List[str] = Field(
        ..., description='User IDs to deactivate', ge=1, le=100, title='User IDs'
    )


class DeactivateUsersResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    task_id: str


class DeleteCampaignResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class DeleteChannelsRequest(BaseModel):
    cids: Optional[List[str]] = Field(
        None,
        description='All channels that should be deleted',
        ge=1,
        le=100,
        title='Channels CID',
    )
    hard_delete: Optional[bool] = Field(
        None,
        description='Specify if channels and all ressources should be hard deleted',
        title='Hard delete',
    )


class DeleteChannelsResult(BaseModel):
    error: Optional[str] = None
    status: str


class DeleteCommandResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    name: str


class DeleteSegmentResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class Conversations(Enum):
    soft = 'soft'
    hard = 'hard'


class Messages(Enum):
    soft = 'soft'
    pruning = 'pruning'
    hard = 'hard'


class User(Enum):
    soft = 'soft'
    pruning = 'pruning'
    hard = 'hard'


class DeleteUsersRequest(BaseModel):
    conversations: Optional[Conversations] = Field(
        None,
        description="Conversation channels delete mode.\nConversation channel is any channel which only has two members one of which is the user being deleted.\n\n* null or empty string - doesn't delete any conversation channels\n* soft - marks all conversation channels as deleted (same effect as Delete Channels with 'hard' option disabled)\n* hard - deletes channel and all its data completely including messages (same effect as Delete Channels with 'hard' option enabled)\n",
        title='Delete Conversations',
    )
    messages: Optional[Messages] = Field(
        None,
        description="Message delete mode.\n\n* null or empty string - doesn't delete user messages\n* soft - marks all user messages as deleted without removing any related message data\n* pruning - marks all user messages as deleted, nullifies message information and removes some message data such as reactions and flags\n* hard - deletes messages completely with all related information\n",
        title='Delete Messages',
    )
    new_channel_owner_id: Optional[str] = None
    user: Optional[User] = Field(
        None,
        description="User delete mode.\n\n* soft - marks user as deleted and retains all user data\n* pruning - marks user as deleted and nullifies user information\n* hard - deletes user completely. Requires 'hard' option for messages and conversations as well\n",
        title='Delete User',
    )
    user_ids: List[str] = Field(
        ..., description='IDs of users to delete', ge=1, le=100, title='User IDs'
    )


class DeleteUsersResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    task_id: str


class Device(BaseModel):
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    disabled: Optional[bool] = Field(
        None, description='Whether device is disabled or not', title='Disabled'
    )
    disabled_reason: Optional[str] = Field(
        None,
        description='Reason explaining why device had been disabled',
        title='Reason',
    )
    id: str
    push_provider: str
    push_provider_name: Optional[str] = None
    user_id: str


class DeviceErrorInfo(BaseModel):
    error_message: str
    provider: str
    provider_name: str


class DeviceFields(BaseModel):
    id: Optional[str] = Field(None, description='Device ID', title='ID')
    push_provider: Optional[PushProvider] = Field(None, title='Push provider')
    push_provider_name: Optional[str] = Field(
        None,
        description='Name of the push provider configuration',
        title='Push provider name',
    )


class DeviceRequest(BaseModel):
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    disabled: Optional[bool] = Field(
        None, description='Whether device is disabled or not', title='Disabled'
    )
    disabled_reason: Optional[str] = Field(
        None,
        description='Reason explaining why device had been disabled',
        title='Reason',
    )
    id: Optional[str] = None
    push_provider: Optional[str] = None
    push_provider_name: Optional[str] = None
    user_id: Optional[str] = None


class ErrorResult(BaseModel):
    description: Any
    stacktrace: Optional[str] = None
    type: str
    version: Optional[str] = None


class ExportChannelsRequest(BaseModel):
    channels: Optional[List[ChannelExportRequest]] = Field(
        None, description='Export options for channels', ge=1, le=25, title='Channels'
    )
    clear_deleted_message_text: Optional[bool] = Field(
        None,
        description='Set if deleted message text should be cleared',
        title='Clear deleted message text',
    )
    export_users: Optional[bool] = None
    include_truncated_messages: Optional[bool] = Field(
        None,
        description='Set if you want to include truncated messages',
        title='Include truncated messages',
    )
    version: Optional[str] = None


class ExportChannelsResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    task_id: str


class ExportChannelsResult(BaseModel):
    path: Optional[str] = Field(None, description='S3 path of result', title='Path')
    s3_bucket_name: Optional[str] = Field(
        None, description='S3 bucket name result', title='S3 bucket name'
    )
    url: str = Field(..., description='URL of result', title='URL')


class ExportUsersRequest(BaseModel):
    user_ids: List[str] = Field(..., ge=1, le=25)


class ExportUsersResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    task_id: str


class FieldModel(BaseModel):
    short: bool
    title: str
    value: str


class FieldRequest(BaseModel):
    short: Optional[bool] = None
    title: Optional[str] = None
    value: Optional[str] = None


class FileDeleteResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class FileUploadConfig(BaseModel):
    allowed_file_extensions: List[str]
    allowed_mime_types: List[str]
    blocked_file_extensions: List[str]
    blocked_mime_types: List[str]


class FileUploadConfigRequest(BaseModel):
    allowed_file_extensions: Optional[List[str]] = None
    allowed_mime_types: Optional[List[str]] = None
    blocked_file_extensions: Optional[List[str]] = None
    blocked_mime_types: Optional[List[str]] = None


class FileUploadResponse(BaseModel):
    duration: str
    file: Optional[str] = Field(
        None,
        description='URL to the uploaded asset. Should be used to put to `asset_url` attachment field',
        title='File',
    )
    thumb_url: Optional[str] = Field(
        None,
        description='URL of the file thumbnail for supported file formats. Should be put to `thumb_url` attachment field',
        title='Thumbnail URL',
    )


class FirebaseConfigFields(BaseModel):
    apn_template: str
    credentials_json: Optional[str] = None
    data_template: str
    enabled: bool
    notification_template: str
    server_key: Optional[str] = None


class FirebaseConfigRequest(BaseModel):
    Disabled: Optional[bool] = None
    apn_template: Optional[str] = None
    credentials_json: Optional[str] = None
    data_template: Optional[str] = None
    notification_template: Optional[str] = None
    server_key: Optional[str] = None


class FlagMessageDetails(BaseModel):
    pin_changed: Optional[bool] = None
    should_enrich: Optional[bool] = None
    skip_push: Optional[bool] = None
    updated_by_id: Optional[str] = None


class GetBlockListResponse(BaseModel):
    blocklist: Optional[BlockList] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class GetCallTokenResponse(BaseModel):
    agora_app_id: Optional[str] = None
    agora_uid: Optional[float] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    token: str


class GetCommandResponse(BaseModel):
    args: str
    created_at: Optional[datetime] = None
    description: str
    duration: str
    name: str
    set: str
    updated_at: Optional[datetime] = None


class GetExportChannelsStatusResponse(BaseModel):
    created_at: datetime
    duration: str
    error: Optional[ErrorResult] = Field(
        None, description='Contains task error in case of failure', title='Error'
    )
    result: Optional[ExportChannelsResult] = Field(
        None, description='Contains task result in case of success', title='Result'
    )
    status: str
    task_id: str
    updated_at: datetime


class GetTaskResponse(BaseModel):
    created_at: datetime
    duration: str
    error: Optional[ErrorResult] = Field(
        None, description='Error produced by task', title='Error'
    )
    result: Optional[Dict[str, Any]] = Field(
        None, description='Result produced by task after completion', title='Result'
    )
    status: str = Field(..., description='Current status of task', title='Status')
    task_id: str = Field(..., description='ID of task', title='Task ID')
    updated_at: datetime


class HMSCall(BaseModel):
    room_id: str
    room_name: str


class HideChannelResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class HuaweiConfigFields(BaseModel):
    enabled: bool
    id: Optional[str] = None
    secret: Optional[str] = None


class HuaweiConfigRequest(BaseModel):
    Disabled: Optional[bool] = None
    id: Optional[str] = None
    secret: Optional[str] = None


class ImageData(BaseModel):
    frames: str
    height: str
    size: str
    url: str
    width: str


class ImageDataRequest(BaseModel):
    frames: Optional[str] = None
    height: Optional[str] = None
    size: Optional[str] = None
    url: Optional[str] = None
    width: Optional[str] = None


class Crop(Enum):
    top = 'top'
    bottom = 'bottom'
    left = 'left'
    right = 'right'
    center = 'center'


class Resize(Enum):
    clip = 'clip'
    crop = 'crop'
    scale = 'scale'
    fill = 'fill'


class ImageSize(BaseModel):
    crop: Crop = Field(..., description='Crop mode', title='Crop')
    height: float = Field(..., description='Target image height', title='Height')
    resize: Resize = Field(..., description='Resize method', title='Resize')
    width: float = Field(..., description='Target image width', title='Width')


class ImageSizeRequest(BaseModel):
    crop: Optional[Crop] = Field(None, description='Crop mode', title='Crop')
    height: Optional[float] = Field(
        None, description='Target image height', title='Height'
    )
    resize: Optional[Resize] = Field(None, description='Resize method', title='Resize')
    width: Optional[float] = Field(
        None, description='Target image width', title='Width'
    )


class ImageUploadResponse(BaseModel):
    duration: str
    file: Optional[str] = Field(
        None,
        description='URL to the uploaded asset. Should be used to put to `asset_url` attachment field',
        title='File',
    )
    thumb_url: Optional[str] = Field(
        None,
        description='URL of the file thumbnail for supported file formats. Should be put to `thumb_url` attachment field',
        title='Thumbnail URL',
    )
    upload_sizes: Optional[List[ImageSize]] = None


class Images(BaseModel):
    fixed_height: ImageData
    fixed_height_downsampled: ImageData
    fixed_height_still: ImageData
    fixed_width: ImageData
    fixed_width_downsampled: ImageData
    fixed_width_still: ImageData
    original: ImageData


class ImagesRequest(BaseModel):
    fixed_height: Optional[ImageDataRequest] = None
    fixed_height_downsampled: Optional[ImageDataRequest] = None
    fixed_height_still: Optional[ImageDataRequest] = None
    fixed_width: Optional[ImageDataRequest] = None
    fixed_width_downsampled: Optional[ImageDataRequest] = None
    fixed_width_still: Optional[ImageDataRequest] = None
    original: Optional[ImageDataRequest] = None


class ImportTaskHistory(BaseModel):
    created_at: datetime
    next_state: str
    prev_state: str


class LabelThresholds(BaseModel):
    block: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description='Threshold for automatic message block', title='Block'
    )
    flag: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description='Threshold for automatic message flag', title='Flag'
    )


class LabelThresholdsRequest(BaseModel):
    block: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description='Threshold for automatic message block', title='Block'
    )
    flag: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description='Threshold for automatic message flag', title='Flag'
    )


class LimitInfo(BaseModel):
    limit: float = Field(
        ...,
        description='The maximum number of calls allowed for the time window',
        title='Limit',
    )
    remaining: float = Field(
        ...,
        description='The number of remaining calls in the current window',
        title='Remaining',
    )
    reset: float = Field(
        ..., description='The Unix timestamp of the next window', title='Reset'
    )


class ListBlockListResponse(BaseModel):
    blocklists: List[BlockList]
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class ListCommandsResponse(BaseModel):
    commands: List[Command]
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class ListDevicesResponse(BaseModel):
    devices: List[Device] = Field(..., description='List of devices', title='Devices')
    duration: str


class Type1(Enum):
    regular = 'regular'
    ephemeral = 'ephemeral'
    error = 'error'
    reply = 'reply'
    system = 'system'
    deleted = 'deleted'


class MessagePaginationParamsRequest(BaseModel):
    created_at_after: Optional[datetime] = None
    created_at_after_or_equal: Optional[datetime] = None
    created_at_around: Optional[datetime] = None
    created_at_before: Optional[datetime] = None
    created_at_before_or_equal: Optional[datetime] = None
    id_around: Optional[str] = None
    id_gt: Optional[str] = None
    id_gte: Optional[str] = None
    id_lt: Optional[str] = None
    id_lte: Optional[str] = None
    limit: Optional[confloat(ge=0.0)] = None
    offset: Optional[float] = None


class ModerationResponse(BaseModel):
    action: str
    explicit: float
    spam: float
    toxic: float


class ModerationResponseRequest(BaseModel):
    action: Optional[str] = None
    explicit: Optional[float] = None
    spam: Optional[float] = None
    toxic: Optional[float] = None


class OnlyUserIDRequest(BaseModel):
    id: str


class PaginationParamsRequest(BaseModel):
    id_gt: Optional[float] = None
    id_gte: Optional[float] = None
    id_lt: Optional[float] = None
    id_lte: Optional[float] = None
    limit: Optional[confloat(ge=0.0)] = None
    offset: Optional[float] = None


class Level(Enum):
    app = 'app'
    channel = 'channel'


class Permission(BaseModel):
    action: str = Field(
        ...,
        description='Action name this permission is for (e.g. SendMessage)',
        title='Action',
    )
    condition: Optional[Dict[str, Any]] = Field(
        None,
        description='MongoDB style condition which decides whether or not the permission is granted',
        title='Condition',
    )
    custom: bool = Field(
        ...,
        description='Whether this is a custom permission or built-in',
        title='Custom',
    )
    description: str = Field(
        ..., description='Description of the permission', title='Description'
    )
    id: str = Field(..., description='Unique permission ID', title='ID')
    level: Level = Field(
        ...,
        description='Level at which permission could be applied (app or channel)',
        title='Level',
    )
    name: str = Field(..., description='Name of the permission', title='Name')
    owner: bool = Field(
        ...,
        description='Whether this permission applies to resource owner or not',
        title='Owner',
    )
    same_team: bool = Field(
        ...,
        description='Whether this permission applies to teammates (multi-tenancy mode only)',
        title='Same team',
    )
    tags: List[str] = Field(
        ..., description='List of tags of the permission', title='Tags'
    )


class Policy(BaseModel):
    action: float
    created_at: datetime
    name: str
    owner: bool
    priority: float
    resources: List[str]
    roles: List[str]
    updated_at: datetime


class Action1(Enum):
    Deny = 'Deny'
    Allow = 'Allow'


class PolicyRequest(BaseModel):
    action: Optional[Action1] = Field(None, title='Action')
    name: str = Field(..., description='User-friendly policy name', title='Name')
    owner: Optional[bool] = Field(
        None,
        description='Whether policy applies to resource owner or not',
        title='Owner',
    )
    priority: confloat(ge=1.0, le=999.0) = Field(
        ..., description='Policy priority', title='Priority'
    )
    resources: Optional[List[str]] = Field(
        None,
        description='List of resources to apply policy to',
        ge=1,
        title='Resources',
    )
    roles: Optional[List[str]] = Field(
        None, description='List of roles to apply policy to', title='Roles'
    )


class PolicyRequest1(BaseModel):
    action: Action1 = Field(..., title='Action')
    name: str = Field(..., description='User-friendly policy name', title='Name')
    owner: bool = Field(
        ...,
        description='Whether policy applies to resource owner or not',
        title='Owner',
    )
    priority: confloat(ge=1.0, le=999.0) = Field(
        ..., description='Policy priority', title='Priority'
    )
    resources: List[str] = Field(
        ..., description='List of resources to apply policy to', ge=1, title='Resources'
    )
    roles: List[str] = Field(
        ..., description='List of roles to apply policy to', title='Roles'
    )


class Version(Enum):
    v1 = 'v1'
    v2 = 'v2'


class PushConfigRequest(BaseModel):
    offline_only: Optional[bool] = None
    version: Optional[Version] = None


class PushNotificationSettings(BaseModel):
    disabled: Optional[bool] = None
    disabled_until: Optional[datetime] = None


class PushNotificationSettingsRequest(BaseModel):
    disabled: Optional[bool] = None
    disabled_until: Optional[datetime] = None


class PushProviderModel(BaseModel):
    apn_auth_key: Optional[str] = None
    apn_auth_type: Optional[str] = None
    apn_development: Optional[bool] = None
    apn_host: Optional[str] = None
    apn_key_id: Optional[str] = None
    apn_notification_template: Optional[str] = None
    apn_p12_cert: Optional[str] = None
    apn_team_id: Optional[str] = None
    apn_topic: Optional[str] = None
    created_at: datetime
    description: Optional[constr(max_length=128)] = None
    disabled_at: Optional[datetime] = None
    disabled_reason: Optional[constr(max_length=255)] = None
    firebase_apn_template: Optional[str] = None
    firebase_credentials: Optional[str] = None
    firebase_data_template: Optional[str] = None
    firebase_notification_template: Optional[str] = None
    firebase_server_key: Optional[str] = None
    huawei_app_id: Optional[str] = None
    huawei_app_secret: Optional[str] = None
    name: constr(min_length=1, max_length=36)
    type: float
    updated_at: datetime
    xiaomi_app_secret: Optional[str] = None
    xiaomi_package_name: Optional[str] = None


class PushProviderRequest(BaseModel):
    apn_auth_key: Optional[str] = None
    apn_auth_type: Optional[str] = None
    apn_development: Optional[bool] = None
    apn_host: Optional[str] = None
    apn_key_id: Optional[str] = None
    apn_notification_template: Optional[str] = None
    apn_p12_cert: Optional[str] = None
    apn_team_id: Optional[str] = None
    apn_topic: Optional[str] = None
    created_at: Optional[datetime] = None
    description: Optional[constr(max_length=128)] = None
    disabled_at: Optional[datetime] = None
    disabled_reason: Optional[constr(max_length=255)] = None
    firebase_apn_template: Optional[str] = None
    firebase_credentials: Optional[str] = None
    firebase_data_template: Optional[str] = None
    firebase_notification_template: Optional[str] = None
    firebase_server_key: Optional[str] = None
    huawei_app_id: Optional[str] = None
    huawei_app_secret: Optional[str] = None
    name: constr(min_length=1, max_length=36)
    type: Optional[float] = None
    updated_at: Optional[datetime] = None
    xiaomi_app_secret: Optional[str] = None
    xiaomi_package_name: Optional[str] = None


class ReactivateUserRequest(BaseModel):
    created_by_id: Optional[str] = Field(
        None,
        description="ID of the user who's reactivating the user",
        title='Created by ID',
    )
    name: Optional[str] = Field(
        None, description='Set this field to put new name for the user', title='Name'
    )
    restore_messages: Optional[bool] = Field(
        None,
        description='Restore previously deleted messages',
        title='Restore messages',
    )
    user_id: str = Field(..., title='User ID')


class ReactivateUsersRequest(BaseModel):
    created_by_id: Optional[str] = Field(
        None,
        description="ID of the user who's reactivating the users",
        title='Created by ID',
    )
    restore_messages: Optional[bool] = Field(
        None,
        description='Restore previously deleted messages',
        title='Restore messages',
    )
    user_ids: List[str] = Field(
        ..., description='User IDs to reactivate', ge=1, le=100, title='User IDs'
    )


class ReactivateUsersResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    task_id: str


class Recipient(BaseModel):
    campaign_id: str
    channel_cid: str
    created_at: datetime
    details: str
    message_id: str
    receiver_id: str
    status: str
    updated_at: datetime


class Response(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class RestoreUsersRequest(BaseModel):
    user_ids: List[str] = Field(..., ge=1, le=100)


class ResumeCampaignRequest(BaseModel):
    pass


class RoleModel(BaseModel):
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    custom: bool = Field(
        ..., description='Whether this is a custom role or built-in', title='Custom'
    )
    name: str = Field(..., description='Unique role name', title='Name')
    scopes: List[str] = Field(
        ...,
        description='List of scopes where this role is currently present. `.app` means that role is present in app-level grants',
        title='Scopes',
    )
    updated_at: datetime = Field(
        ..., description='Date/time of the last update', title='Updated at'
    )


class ScheduleCampaignRequest(BaseModel):
    scheduled_for: Optional[confloat(ge=0.0)] = None


class SearchWarning(BaseModel):
    channel_search_cids: Optional[List[str]] = Field(
        None,
        description='Channel CIDs for the searched channels',
        title='Channel Search CIDs',
    )
    channel_search_count: Optional[float] = Field(
        None, description='Number of channels searched', title='Channel Search Count'
    )
    warning_code: float = Field(
        ..., description='Code corresponding to the warning', title='Warning Code'
    )
    warning_description: str = Field(
        ..., description='Description of the warning', title='Warning Description'
    )


class Type3(Enum):
    user = 'user'
    channel = 'channel'


class Segment(BaseModel):
    created_at: datetime
    description: constr(max_length=256)
    filter: Dict[str, Any]
    id: str
    in_use: bool
    name: constr(max_length=128)
    size: float
    status: str
    type: Type3
    updated_at: datetime


class SegmentDataRequest(BaseModel):
    description: Optional[constr(max_length=256)] = None
    filter: Dict[str, Any]
    name: constr(max_length=128)
    type: Type3


class SegmentUpdateableFieldsRequest(BaseModel):
    description: Optional[constr(max_length=256)] = None
    filter: Optional[Dict[str, Any]] = None
    name: Optional[constr(max_length=128)] = None
    type: Optional[Type3] = None


class ShowChannelResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class SortParam(BaseModel):
    direction: Optional[float] = None
    field: Optional[str] = None


class SortParamRequest(BaseModel):
    direction: Optional[float] = None
    field: Optional[str] = None


class StopCampaignRequest(BaseModel):
    pass


class StopWatchingResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class TestCampaignRequest(BaseModel):
    users: List[str] = Field(..., ge=1, le=10)


class TestCampaignResponse(BaseModel):
    details: Optional[str] = None
    duration: str
    results: Optional[Dict[str, str]] = Field(
        None, description='Result of the test per user', title='Results'
    )
    status: str


class Thresholds(BaseModel):
    explicit: Optional[LabelThresholds] = Field(
        None, description='Thresholds for explicit messages', title='Explicit'
    )
    spam: Optional[LabelThresholds] = Field(
        None, description='Thresholds for spam', title='Spam'
    )
    toxic: Optional[LabelThresholds] = Field(
        None, description='Thresholds for toxic messages', title='Toxic'
    )


class ThresholdsRequest(BaseModel):
    explicit: Optional[LabelThresholdsRequest] = Field(
        None, description='Thresholds for explicit messages', title='Explicit'
    )
    spam: Optional[LabelThresholdsRequest] = Field(
        None, description='Thresholds for spam', title='Spam'
    )
    toxic: Optional[LabelThresholdsRequest] = Field(
        None, description='Thresholds for toxic messages', title='Toxic'
    )


class Language(Enum):
    af = 'af'
    sq = 'sq'
    am = 'am'
    ar = 'ar'
    az = 'az'
    bn = 'bn'
    bs = 'bs'
    bg = 'bg'
    zh = 'zh'
    zh_TW = 'zh-TW'
    hr = 'hr'
    cs = 'cs'
    da = 'da'
    fa_AF = 'fa-AF'
    nl = 'nl'
    en = 'en'
    et = 'et'
    fi = 'fi'
    fr = 'fr'
    fr_CA = 'fr-CA'
    ka = 'ka'
    de = 'de'
    el = 'el'
    ha = 'ha'
    he = 'he'
    hi = 'hi'
    hu = 'hu'
    id = 'id'
    it = 'it'
    ja = 'ja'
    ko = 'ko'
    lv = 'lv'
    ms = 'ms'
    no = 'no'
    fa = 'fa'
    ps = 'ps'
    pl = 'pl'
    pt = 'pt'
    ro = 'ro'
    ru = 'ru'
    sr = 'sr'
    sk = 'sk'
    sl = 'sl'
    so = 'so'
    es = 'es'
    es_MX = 'es-MX'
    sw = 'sw'
    sv = 'sv'
    tl = 'tl'
    ta = 'ta'
    th = 'th'
    tr = 'tr'
    uk = 'uk'
    ur = 'ur'
    vi = 'vi'


class TranslateMessageRequest(BaseModel):
    language: Language = Field(
        ..., description='Language to translate message to', title='Language'
    )


class UnmuteResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class EnforceUniqueUsernames(Enum):
    no = 'no'
    app = 'app'
    team = 'team'


class PermissionVersion(Enum):
    v1 = 'v1'
    v2 = 'v2'


class VideoProvider(Enum):
    agora = 'agora'
    hms = 'hms'


class UpdateBlockListRequest(BaseModel):
    Name: Optional[str] = None
    words: Optional[List[str]] = None


class UpdateChannelTypeRequest(BaseModel):
    NameFromPath: Optional[str] = None
    automod: Automod
    automod_behavior: Optional[AutomodBehavior] = None
    automod_thresholds: Optional[ThresholdsRequest] = None
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: Optional[List[str]] = Field(
        None, description='List of commands that channel supports', title='Commands'
    )
    connect_events: Optional[bool] = None
    custom_events: Optional[bool] = None
    grants: Optional[Dict[str, List[str]]] = None
    max_message_length: Optional[confloat(le=20000.0)] = None
    message_retention: Optional[str] = None
    mutes: Optional[bool] = None
    permissions: Optional[List[PolicyRequest]] = None
    push_notifications: Optional[bool] = None
    quotes: Optional[bool] = None
    reactions: Optional[bool] = None
    read_events: Optional[bool] = None
    reminders: Optional[bool] = None
    replies: Optional[bool] = None
    search: Optional[bool] = None
    typing_events: Optional[bool] = None
    uploads: Optional[bool] = None
    url_enrichment: Optional[bool] = None


class UpdateChannelTypeResponse(BaseModel):
    automod: Automod
    automod_behavior: AutomodBehavior
    automod_thresholds: Optional[Thresholds] = None
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: List[str]
    connect_events: bool
    created_at: datetime
    custom_events: bool
    duration: str
    grants: Dict[str, List[str]]
    max_message_length: confloat(le=20000.0)
    message_retention: str
    mutes: bool
    name: str
    permissions: List[PolicyRequest1]
    push_notifications: bool
    quotes: bool
    reactions: bool
    read_events: bool
    reminders: bool
    replies: bool
    search: bool
    typing_events: bool
    updated_at: datetime
    uploads: bool
    url_enrichment: bool


class UpdateCommandRequest(BaseModel):
    Name: Optional[str] = None
    args: Optional[constr(max_length=255)] = Field(
        None,
        description='Arguments help text, shown in commands auto-completion',
        title='Arguments',
    )
    description: constr(max_length=255) = Field(
        ...,
        description='Description, shown in commands auto-completion',
        title='Description',
    )
    set: Optional[constr(max_length=255)] = Field(
        None, description='Set name used for grouping commands', title='Set'
    )


class UpdateCommandResponse(BaseModel):
    command: Optional[Command] = None
    duration: str


class UpdateSegmentRequest(BaseModel):
    segment: SegmentUpdateableFieldsRequest


class UpdateSegmentResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    segment: Optional[Segment] = None


class UpdateUserPartialRequest(BaseModel):
    id: str = Field(..., description='User ID to update', title='ID')
    set: Dict[str, Any]
    unset: List[str]


class UpsertPushProviderRequest(BaseModel):
    push_provider: Optional[PushProviderRequest] = None


class UpsertPushProviderResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    push_provider: PushProviderModel


class UserCustomEventRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    created_at: Optional[datetime] = None
    type: str


class UserObject(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    ban_expires: Optional[datetime] = Field(
        None, description='Expiration date of the ban', title='Ban expires'
    )
    banned: bool = Field(
        ..., description='Whether a user is banned or not', title='Banned'
    )
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    deactivated_at: Optional[datetime] = Field(
        None, description='Date of deactivation', title='Deactivated at'
    )
    deleted_at: Optional[datetime] = Field(
        None, description='Date/time of deletion', title='Deleted at'
    )
    id: str = Field(..., description='Unique user identifier', title='ID')
    invisible: Optional[bool] = None
    language: Optional[str] = Field(
        None, description='Preferred language of a user', title='Language'
    )
    last_active: Optional[datetime] = Field(
        None, description='Date of last activity', title='Last active'
    )
    online: bool = Field(
        ..., description='Whether a user online or not', title='Online'
    )
    push_notifications: Optional[PushNotificationSettings] = None
    revoke_tokens_issued_before: Optional[datetime] = Field(
        None,
        description='Revocation date for tokens',
        title='Revoke tokens issued before',
    )
    role: str = Field(
        ..., description='Determines the set of user permissions', title='Role'
    )
    teams: Optional[List[str]] = Field(
        None, description='List of teams user is a part of', title='Teams'
    )
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )


class UserObjectRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    ban_expires: Optional[datetime] = Field(
        None, description='Expiration date of the ban', title='Ban expires'
    )
    banned: Optional[bool] = Field(
        None, description='Whether a user is banned or not', title='Banned'
    )
    id: str = Field(..., description='Unique user identifier', title='ID')
    invisible: Optional[bool] = None
    language: Optional[str] = Field(
        None, description='Preferred language of a user', title='Language'
    )
    push_notifications: Optional[PushNotificationSettingsRequest] = None
    revoke_tokens_issued_before: Optional[datetime] = Field(
        None,
        description='Revocation date for tokens',
        title='Revoke tokens issued before',
    )
    role: Optional[str] = Field(
        None, description='Determines the set of user permissions', title='Role'
    )
    teams: Optional[List[str]] = Field(
        None, description='List of teams user is a part of', title='Teams'
    )


class UserPresenceChangedEvent(BaseModel):
    created_at: datetime
    type: str
    user: Optional[UserObject] = None


class UserReactivatedEvent(BaseModel):
    created_at: datetime
    type: str
    user: Optional[UserObject] = None


class UserResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    ban_expires: Optional[datetime] = None
    banned: bool
    created_at: Optional[datetime] = None
    deactivated_at: Optional[datetime] = None
    deleted_at: Optional[datetime] = None
    id: str
    invisible: Optional[bool] = None
    language: Optional[str] = None
    last_active: Optional[datetime] = None
    online: bool
    push_notifications: Optional[PushNotificationSettings] = None
    revoke_tokens_issued_before: Optional[datetime] = None
    role: str
    shadow_banned: bool = Field(
        ..., description='Whether user is shadow banned or not', title='Shadow banned'
    )
    teams: Optional[List[str]] = None
    updated_at: Optional[datetime] = None


class UserUnbannedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    shadow: bool
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class UserUnmutedEvent(BaseModel):
    created_at: datetime
    target_user: Optional[str] = None
    target_users: Optional[List[str]] = None
    type: str
    user: Optional[UserObject] = None


class UserUpdatedEvent(BaseModel):
    created_at: datetime
    type: str
    user: Optional[UserObject] = None


class UserWatchingStartEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None
    watcher_count: float


class UserWatchingStopEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    type: str
    user: Optional[UserObject] = None
    watcher_count: float


class UsersResponse(BaseModel):
    duration: str
    users: List[UserResponse] = Field(
        ..., description='List of found users', title='Users'
    )


class XiaomiConfigFields(BaseModel):
    enabled: bool
    package_name: Optional[str] = None
    secret: Optional[str] = None


class XiaomiConfigRequest(BaseModel):
    Disabled: Optional[bool] = None
    package_name: Optional[str] = None
    secret: Optional[str] = None


class Ids(RootModel[List[str]]):
    root: List[str] = Field(
        ..., description='List of comma-separated IDs', ge=1, le=50, title='IDs'
    )


class Json(BaseModel):
    device: Optional[DeviceFields] = None
    user_details: UserObject


class Payload2(BaseModel):
    filter_conditions: Optional[Dict[str, Any]] = None
    limit: Optional[confloat(ge=0.0, le=300.0)] = None
    offset: Optional[confloat(le=10000.0)] = None
    user: Optional[UserObject] = Field(
        None,
        description='**Server-side only**. User object which server acts upon',
        title='User',
    )
    user_id: Optional[str] = Field(
        None,
        description='**Server-side only**. User ID which server acts upon',
        title='User ID',
    )


class Type6(Enum):
    apn = 'apn'
    firebase = 'firebase'
    huawei = 'huawei'
    xiaomi = 'xiaomi'


class Payload3(BaseModel):
    created_at_after: Optional[datetime] = None
    created_at_after_or_equal: Optional[datetime] = None
    created_at_before: Optional[datetime] = None
    created_at_before_or_equal: Optional[datetime] = None
    filter_conditions: Dict[str, Any]
    limit: Optional[confloat(le=300.0)] = None
    offset: Optional[confloat(le=10000.0)] = None
    sort: Optional[List[SortParam]] = Field(None, le=1)
    user: Optional[UserObject] = Field(
        None,
        description='**Server-side only**. User object which server acts upon',
        title='User',
    )
    user_id: Optional[str] = Field(
        None,
        description='**Server-side only**. User ID which server acts upon',
        title='User ID',
    )


class Payload5(BaseModel):
    filter_conditions: Dict[str, Any] = Field(
        ..., description='Channel filter conditions', title='Channel filter'
    )
    limit: Optional[float] = Field(
        None, description='Number of messages to return', title='Limit'
    )
    message_filter_conditions: Optional[Dict[str, Any]] = Field(
        None, description='Message filter conditions', title='Message filter'
    )
    next: Optional[str] = Field(
        None,
        description='Pagination parameter. Cannot be used with non-zero offset.',
        title='Next',
    )
    offset: Optional[float] = Field(
        None,
        description='Pagination offset. Cannot be used with sort or next.',
        title='Offset',
    )
    query: Optional[str] = Field(None, description='Search phrase', title='Query')
    sort: Optional[List[SortParam]] = Field(
        None,
        description='Sort parameters. Cannot be used with non-zero offset',
        title='Sort',
    )


class Payload7(BaseModel):
    client_id: Optional[str] = None
    connection_id: Optional[str] = None
    filter_conditions: Dict[str, Any] = Field(
        ..., description='User filters', title='Filter conditions'
    )
    id_gt: Optional[str] = None
    id_gte: Optional[str] = None
    id_lt: Optional[str] = None
    id_lte: Optional[str] = None
    limit: Optional[confloat(ge=0.0, le=100.0)] = None
    offset: Optional[confloat(le=1000.0)] = None
    presence: Optional[bool] = Field(
        None, description='Request user presence status', title='Presence'
    )
    sort: List[SortParam] = Field(
        ..., description='Array of sort parameters', le=5, title='Sort'
    )
    user: Optional[UserObject] = None
    user_id: Optional[str] = None


class Attachment(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    actions: Optional[List[Action]] = None
    asset_url: Optional[str] = None
    author_icon: Optional[str] = None
    author_link: Optional[str] = None
    author_name: Optional[str] = None
    color: Optional[str] = None
    fallback: Optional[str] = None
    fields: Optional[List[FieldModel]] = None
    footer: Optional[str] = None
    footer_icon: Optional[str] = None
    giphy: Optional[Images] = None
    image_url: Optional[str] = None
    og_scrape_url: Optional[str] = None
    original_height: Optional[float] = None
    original_width: Optional[float] = None
    pretext: Optional[str] = None
    text: Optional[str] = None
    thumb_url: Optional[str] = None
    title: Optional[str] = None
    title_link: Optional[str] = None
    type: Optional[str] = Field(
        None, description='Attachment type (e.g. image, video, url)', title='Type'
    )


class AttachmentRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    actions: Optional[List[ActionRequest]] = None
    asset_url: Optional[str] = None
    author_icon: Optional[str] = None
    author_link: Optional[str] = None
    author_name: Optional[str] = None
    color: Optional[str] = None
    fallback: Optional[str] = None
    fields: Optional[List[FieldRequest]] = None
    footer: Optional[str] = None
    footer_icon: Optional[str] = None
    giphy: Optional[ImagesRequest] = None
    image_url: Optional[str] = None
    og_scrape_url: Optional[str] = None
    original_height: Optional[float] = None
    original_width: Optional[float] = None
    pretext: Optional[str] = None
    text: Optional[str] = None
    thumb_url: Optional[str] = None
    title: Optional[str] = None
    title_link: Optional[str] = None
    type: Optional[str] = Field(
        None, description='Attachment type (e.g. image, video, url)', title='Type'
    )


class BanRequest(BaseModel):
    banned_by: Optional[UserObjectRequest] = Field(
        None, description='User who issued a ban', title='Banned by'
    )
    banned_by_id: Optional[str] = Field(
        None, description='User ID who issued a ban', title='Banned by ID'
    )
    id: Optional[str] = Field(None, description='Channel ID to ban user in', title='ID')
    ip_ban: Optional[bool] = Field(
        None, description='Whether to perform IP ban or not', title='IP ban'
    )
    reason: Optional[str] = Field(None, description='Ban reason', title='Reason')
    shadow: Optional[bool] = Field(
        None, description='Whether to perform shadow ban or not', title='Shadow'
    )
    target_user_id: str = Field(
        ..., description='ID of user to ban', title='Target user ID'
    )
    timeout: Optional[float] = Field(
        None,
        description='Timeout of ban in minutes. User will be unbanned after this period of time',
        title='Timeout',
    )
    type: Optional[str] = Field(
        None, description='Channel type to ban user in', title='Type'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class Call(BaseModel):
    agora: Optional[AgoraCall] = None
    hms: Optional[HMSCall] = None
    id: str
    provider: str
    type: str


class Campaign(BaseModel):
    attachments: List[Attachment] = Field(..., le=10)
    channel_type: constr(max_length=64)
    completed_at: Optional[datetime] = None
    created_at: datetime
    defaults: Dict[str, str]
    description: constr(max_length=1024)
    details: Optional[str] = None
    errored_messages: Optional[float] = None
    failed_at: Optional[datetime] = None
    id: str
    name: constr(max_length=256)
    resumed_at: Optional[datetime] = None
    scheduled_at: Optional[datetime] = None
    scheduled_for: Optional[datetime] = None
    segment_id: str
    sender_id: str
    sent_messages: Optional[float] = None
    status: Optional[str] = None
    stopped_at: Optional[datetime] = None
    task_id: Optional[str] = None
    text: str
    updated_at: datetime


class CampaignDataRequest(BaseModel):
    attachments: Optional[List[AttachmentRequest]] = Field(None, le=10)
    channel_type: Optional[constr(max_length=64)] = None
    defaults: Optional[Dict[str, str]] = None
    description: Optional[constr(max_length=1024)] = None
    name: constr(max_length=256)
    segment_id: str
    sender_id: str
    text: str


class CampaignSort(BaseModel):
    direction: Optional[Direction] = None
    fields: List[CampaignSortField] = Field(..., le=5)


class CampaignUpdateableFieldsRequest(BaseModel):
    attachments: Optional[List[AttachmentRequest]] = Field(None, le=10)
    channel_type: Optional[constr(max_length=64)] = None
    defaults: Optional[Dict[str, str]] = None
    description: Optional[constr(max_length=1024)] = None
    name: Optional[constr(max_length=256)] = None
    segment_id: Optional[str] = None
    sender_id: Optional[str] = None
    text: Optional[str] = None


class ChannelConfig(BaseModel):
    automod: Automod
    automod_behavior: AutomodBehavior
    automod_thresholds: Optional[Thresholds] = None
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: List[str] = Field(
        ..., description='List of commands that channel supports', title='Commands'
    )
    connect_events: bool
    created_at: datetime
    custom_events: bool
    max_message_length: confloat(le=20000.0)
    message_retention: str
    mutes: bool
    name: str
    push_notifications: bool
    quotes: bool
    reactions: bool
    read_events: bool
    reminders: bool
    replies: bool
    search: bool
    typing_events: bool
    updated_at: datetime
    uploads: bool
    url_enrichment: bool


class ChannelConfigWithInfo(BaseModel):
    automod: Automod
    automod_behavior: AutomodBehavior
    automod_thresholds: Optional[Thresholds] = None
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: List[Command]
    connect_events: bool
    created_at: datetime
    custom_events: bool
    grants: Optional[Dict[str, List[str]]] = Field(None, title='Grants')
    max_message_length: confloat(le=20000.0)
    message_retention: str
    mutes: bool
    name: str
    push_notifications: bool
    quotes: bool
    reactions: bool
    read_events: bool
    reminders: bool
    replies: bool
    search: bool
    typing_events: bool
    updated_at: datetime
    uploads: bool
    url_enrichment: bool


class ChannelConfigWithInfoRequest(BaseModel):
    automod: Automod
    automod_behavior: Optional[AutomodBehavior] = None
    automod_thresholds: Optional[ThresholdsRequest] = None
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: Optional[List[CommandRequest]] = None
    connect_events: Optional[bool] = None
    created_at: Optional[datetime] = None
    custom_events: Optional[bool] = None
    grants: Optional[Dict[str, List[str]]] = Field(None, title='Grants')
    max_message_length: Optional[confloat(le=20000.0)] = None
    message_retention: Optional[str] = None
    mutes: Optional[bool] = None
    name: Optional[str] = None
    push_notifications: Optional[bool] = None
    quotes: Optional[bool] = None
    reactions: Optional[bool] = None
    read_events: Optional[bool] = None
    reminders: Optional[bool] = None
    replies: Optional[bool] = None
    search: Optional[bool] = None
    typing_events: Optional[bool] = None
    updated_at: Optional[datetime] = None
    uploads: Optional[bool] = None
    url_enrichment: Optional[bool] = None


class ChannelMember(BaseModel):
    ban_expires: Optional[datetime] = Field(
        None, description='Expiration date of the ban', title='Ban expires'
    )
    banned: bool = Field(
        ..., description='Whether member is banned this channel or not', title='Banned'
    )
    channel_role: str = Field(
        ..., description='Role of the member in the channel', title='Channel Role'
    )
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    deleted_at: Optional[datetime] = None
    invite_accepted_at: Optional[datetime] = Field(
        None, description='Date when invite was accepted', title='Invited accepted at'
    )
    invite_rejected_at: Optional[datetime] = Field(
        None, description='Date when invite was rejected', title='Invited rejected at'
    )
    invited: Optional[bool] = Field(
        None, description='Whether member was invited or not', title='Invited'
    )
    is_moderator: Optional[bool] = Field(
        None,
        description='Whether member is channel moderator or not',
        title='Is moderator',
    )
    role: Optional[Role] = Field(
        None,
        description='Permission level of the member in the channel (DEPRECATED: use channel_role instead)',
        title='Role',
    )
    shadow_banned: bool = Field(
        ...,
        description='Whether member is shadow banned in this channel or not',
        title='Shadow banned',
    )
    updated_at: datetime = Field(
        ..., description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObject] = None
    user_id: Optional[str] = Field(None, title='User ID')


class ChannelMemberRequest(BaseModel):
    ban_expires: Optional[datetime] = Field(
        None, description='Expiration date of the ban', title='Ban expires'
    )
    banned: Optional[bool] = Field(
        None, description='Whether member is banned this channel or not', title='Banned'
    )
    channel_role: Optional[str] = Field(
        None, description='Role of the member in the channel', title='Channel Role'
    )
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    deleted_at: Optional[datetime] = None
    invite_accepted_at: Optional[datetime] = Field(
        None, description='Date when invite was accepted', title='Invited accepted at'
    )
    invite_rejected_at: Optional[datetime] = Field(
        None, description='Date when invite was rejected', title='Invited rejected at'
    )
    invited: Optional[bool] = Field(
        None, description='Whether member was invited or not', title='Invited'
    )
    is_moderator: Optional[bool] = Field(
        None,
        description='Whether member is channel moderator or not',
        title='Is moderator',
    )
    role: Optional[Role] = Field(
        None,
        description='Permission level of the member in the channel (DEPRECATED: use channel_role instead)',
        title='Role',
    )
    shadow_banned: Optional[bool] = Field(
        None,
        description='Whether member is shadow banned in this channel or not',
        title='Shadow banned',
    )
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = Field(None, title='User ID')


class ChannelRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    auto_translation_enabled: Optional[bool] = Field(
        None, description='Enable or disable auto translation', title='Auto translation'
    )
    auto_translation_language: Optional[str] = Field(
        None,
        description='Switch auto translation language',
        title='Auto translation language',
    )
    config_overrides: Optional[ChannelConfigRequest] = None
    created_by: Optional[UserObjectRequest] = None
    disabled: Optional[bool] = None
    frozen: Optional[bool] = Field(
        None, description='Freeze or unfreeze the channel', title='Frozen'
    )
    members: Optional[List[ChannelMemberRequest]] = Field(None, le=100)
    own_capabilities: Optional[List[float]] = None
    team: Optional[str] = Field(
        None,
        description='Team the channel belongs to (if multi-tenant mode is enabled)',
        title='Team',
    )
    truncated_at: Optional[List[float]] = None
    truncated_by: Optional[List[float]] = None
    truncated_by_id: Optional[str] = None


class ChannelResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    auto_translation_enabled: Optional[bool] = Field(
        None,
        description='Whether auto translation is enabled or not',
        title='Auto translation',
    )
    auto_translation_language: Optional[str] = Field(
        None,
        description='Language to translate to when auto translation is active',
        title='Auto translation language',
    )
    cid: str = Field(..., description='Channel CID (<type>:<id>)', title='CID')
    config: Optional[ChannelConfigWithInfo] = Field(
        None, description='Channel configuration', title='Config'
    )
    cooldown: Optional[float] = Field(
        None, description='Cooldown period after sending each message', title='Cooldown'
    )
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    created_by: Optional[UserObject] = Field(
        None, description='Creator of the channel', title='Created by'
    )
    deleted_at: Optional[datetime] = Field(
        None, description='Date/time of deletion', title='Deleted at'
    )
    disabled: bool
    frozen: bool = Field(
        ..., description='Whether channel is frozen or not', title='Frozen'
    )
    hidden: Optional[bool] = Field(
        None,
        description='Whether this channel is hidden by current user or not',
        title='Hidden',
    )
    hide_messages_before: Optional[datetime] = Field(
        None,
        description='Date since when the message history is accessible',
        title='Hide messages before',
    )
    id: str = Field(..., description='Channel unique ID', title='ID')
    last_message_at: Optional[datetime] = Field(
        None, description='Date of the last message sent', title='Last message at'
    )
    member_count: Optional[float] = Field(
        None, description='Number of members in the channel', title='Member count'
    )
    members: Optional[List[ChannelMember]] = Field(
        None, description='List of channel members (max 100)', title='Members'
    )
    mute_expires_at: Optional[datetime] = Field(
        None, description='Date of mute expiration', title='Mute expires at'
    )
    muted: Optional[bool] = Field(
        None, description='Whether this channel is muted or not', title='Muted'
    )
    own_capabilities: Optional[List[str]] = Field(
        None,
        description='List of channel capabilities of authenticated user',
        title='Own Capabilities',
    )
    team: Optional[str] = Field(
        None,
        description='Team the channel belongs to (multi-tenant only)',
        title='Team',
    )
    truncated_at: Optional[datetime] = Field(
        None,
        description='Date of the latest truncation of the channel',
        title='Truncated At',
    )
    truncated_by: Optional[UserObject] = None
    type: str = Field(..., description='Type of the channel', title='Type')
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )


class ChannelResponseRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    auto_translation_enabled: Optional[bool] = Field(
        None,
        description='Whether auto translation is enabled or not',
        title='Auto translation',
    )
    auto_translation_language: Optional[str] = Field(
        None,
        description='Language to translate to when auto translation is active',
        title='Auto translation language',
    )
    cid: Optional[str] = Field(
        None, description='Channel CID (<type>:<id>)', title='CID'
    )
    config: Optional[ChannelConfigWithInfoRequest] = Field(
        None, description='Channel configuration', title='Config'
    )
    cooldown: Optional[float] = Field(
        None, description='Cooldown period after sending each message', title='Cooldown'
    )
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    created_by: Optional[UserObjectRequest] = Field(
        None, description='Creator of the channel', title='Created by'
    )
    deleted_at: Optional[datetime] = Field(
        None, description='Date/time of deletion', title='Deleted at'
    )
    disabled: Optional[bool] = None
    frozen: Optional[bool] = Field(
        None, description='Whether channel is frozen or not', title='Frozen'
    )
    hidden: Optional[bool] = Field(
        None,
        description='Whether this channel is hidden by current user or not',
        title='Hidden',
    )
    hide_messages_before: Optional[datetime] = Field(
        None,
        description='Date since when the message history is accessible',
        title='Hide messages before',
    )
    id: Optional[str] = Field(None, description='Channel unique ID', title='ID')
    last_message_at: Optional[datetime] = Field(
        None, description='Date of the last message sent', title='Last message at'
    )
    member_count: Optional[float] = Field(
        None, description='Number of members in the channel', title='Member count'
    )
    members: Optional[List[ChannelMemberRequest]] = Field(
        None, description='List of channel members (max 100)', title='Members'
    )
    mute_expires_at: Optional[datetime] = Field(
        None, description='Date of mute expiration', title='Mute expires at'
    )
    muted: Optional[bool] = Field(
        None, description='Whether this channel is muted or not', title='Muted'
    )
    own_capabilities: Optional[List[str]] = Field(
        None,
        description='List of channel capabilities of authenticated user',
        title='Own Capabilities',
    )
    team: Optional[str] = Field(
        None,
        description='Team the channel belongs to (multi-tenant only)',
        title='Team',
    )
    truncated_at: Optional[datetime] = Field(
        None,
        description='Date of the latest truncation of the channel',
        title='Truncated At',
    )
    truncated_by: Optional[UserObjectRequest] = None
    type: Optional[str] = Field(None, description='Type of the channel', title='Type')
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )


class ChannelTruncatedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    type: str


class ChannelTypeConfig(BaseModel):
    automod: Automod
    automod_behavior: AutomodBehavior
    automod_thresholds: Optional[Thresholds] = None
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: List[Command] = Field(
        ..., description='List of commands that channel supports', title='Commands'
    )
    connect_events: bool
    created_at: datetime
    custom_events: bool
    grants: Dict[str, List[str]]
    max_message_length: confloat(le=20000.0)
    message_retention: str
    mutes: bool
    name: str
    permissions: List[PolicyRequest1]
    push_notifications: bool
    quotes: bool
    reactions: bool
    read_events: bool
    reminders: bool
    replies: bool
    search: bool
    typing_events: bool
    updated_at: datetime
    uploads: bool
    url_enrichment: bool


class ChannelVisibleEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    type: str
    user: Optional[UserObject] = None


class CheckPushRequest(BaseModel):
    apn_template: Optional[str] = Field(
        None, description='Push message template for APN', title='APN template'
    )
    firebase_data_template: Optional[str] = Field(
        None,
        description='Push message data template for Firebase',
        title='Firebase data template',
    )
    firebase_template: Optional[str] = Field(
        None,
        description='Push message template for Firebase',
        title='Firebase template',
    )
    message_id: Optional[str] = Field(
        None, description='Message ID to send push notification for', title='Message ID'
    )
    push_provider_name: Optional[str] = Field(
        None, description='Name of push provider', title='Name of push provider'
    )
    push_provider_type: Optional[PushProviderType] = Field(
        None, description='Push provider type', title='Type of push provider'
    )
    skip_devices: Optional[bool] = Field(
        None,
        description="Don't require existing devices to render templates",
        title='Skip devices',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class CheckPushResponse(BaseModel):
    device_errors: Optional[Dict[str, DeviceErrorInfo]] = Field(
        None, description='Object with device errors', title='Device errors'
    )
    duration: str
    general_errors: Optional[List[str]] = Field(
        None, description='List of general errors', title='General errors'
    )
    rendered_apn_template: Optional[str] = Field(None, title='Rendered APN template')
    rendered_firebase_template: Optional[str] = Field(
        None, title='Rendered Firebase template'
    )
    rendered_message: Optional[Dict[str, str]] = Field(None, title='Rendered message')
    skip_devices: Optional[bool] = Field(
        None,
        description="Don't require existing devices to render templates",
        title='Skip devices',
    )


class ConnectRequest(BaseModel):
    device: Optional[DeviceFields] = None
    user_details: UserObject


class CreateCallRequest(BaseModel):
    id: str
    options: Optional[Dict[str, Any]] = None
    type: Type
    user: Optional[UserObjectRequest] = Field(
        None,
        description='**Server-side only**. User object which server acts upon',
        title='User',
    )
    user_id: Optional[str] = Field(
        None,
        description='**Server-side only**. User ID which server acts upon',
        title='User ID',
    )


class CreateCallResponse(BaseModel):
    agora_app_id: Optional[str] = None
    agora_uid: Optional[float] = None
    call: Optional[Call] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    token: str


class CreateCampaignRequest(BaseModel):
    campaign: CampaignDataRequest


class CreateCampaignResponse(BaseModel):
    campaign: Optional[Campaign] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class CreateChannelTypeRequest(BaseModel):
    automod: Automod = Field(
        ..., description='Enables automatic message moderation', title='Auto moderation'
    )
    automod_behavior: Optional[AutomodBehavior] = Field(
        None,
        description='Sets behavior of automatic moderation',
        title='Auto moderation behavior',
    )
    blocklist: Optional[str] = Field(
        None, description='Name of the blocklist to use', title='Blocklist'
    )
    blocklist_behavior: Optional[BlocklistBehavior] = Field(
        None, description='Sets behavior of blocklist', title='Blocklist behavior'
    )
    commands: Optional[List[str]] = Field(
        None, description='List of commands that channel supports', title='Commands'
    )
    connect_events: Optional[bool] = Field(
        None, description='Connect events support', title='Connect events'
    )
    custom_events: Optional[bool] = Field(
        None, description='Enables custom events', title='Custom events'
    )
    grants: Optional[Dict[str, List[str]]] = None
    max_message_length: Optional[float] = Field(
        None,
        description='Number of maximum message characters',
        title='Maximum message length',
    )
    message_retention: Optional[str] = Field(
        None,
        description="Number of days to keep messages. 'infinite' disables retention",
        title='Message retention',
    )
    mutes: Optional[bool] = Field(None, description='Enables mutes', title='Mutes')
    name: str = Field(..., description='Channel type name', title='Name')
    permissions: Optional[List[PolicyRequest]] = Field(
        None,
        description='List of permissions for the channel type',
        title='Permissions',
    )
    push_notifications: Optional[bool] = Field(
        None, description='Enables push notifications', title='Push notifications'
    )
    reactions: Optional[bool] = Field(
        None, description='Enables message reactions', title='Reactions'
    )
    read_events: Optional[bool] = Field(
        None, description='Read events support', title='Read events'
    )
    replies: Optional[bool] = Field(
        None, description='Enables message replies (threads)', title='Replies'
    )
    search: Optional[bool] = Field(
        None, description='Enables message search', title='Search'
    )
    typing_events: Optional[bool] = Field(
        None, description='Typing events support', title='Typing events'
    )
    uploads: Optional[bool] = Field(
        None, description='Enables file uploads', title='Uploads'
    )
    url_enrichment: Optional[bool] = Field(
        None, description='Enables URL enrichment', title='URL enrichment'
    )


class CreateChannelTypeResponse(BaseModel):
    automod: Automod
    automod_behavior: AutomodBehavior
    automod_thresholds: Optional[Thresholds] = None
    blocklist: Optional[str] = None
    blocklist_behavior: Optional[BlocklistBehavior] = None
    commands: List[str]
    connect_events: bool
    created_at: datetime
    custom_events: bool
    duration: str
    grants: Dict[str, List[str]]
    max_message_length: confloat(le=20000.0)
    message_retention: str
    mutes: bool
    name: str
    permissions: List[PolicyRequest1]
    push_notifications: bool
    quotes: bool
    reactions: bool
    read_events: bool
    reminders: bool
    replies: bool
    search: bool
    typing_events: bool
    updated_at: datetime
    uploads: bool
    url_enrichment: bool


class CreateDeviceRequest(BaseModel):
    id: Optional[constr(min_length=1, max_length=255)] = None
    push_provider: Optional[PushProvider] = None
    push_provider_name: Optional[str] = None
    user: Optional[UserObjectRequest] = Field(
        None,
        description='**Server-side only**. User object which server acts upon',
        title='User',
    )
    user_id: Optional[str] = Field(
        None,
        description='**Server-side only**. User ID which server acts upon',
        title='User ID',
    )


class CreateRoleResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    role: RoleModel


class CreateSegmentRequest(BaseModel):
    segment: SegmentDataRequest


class CreateSegmentResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    segment: Optional[Segment] = None


class DeactivateUserResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    user: Optional[UserObject] = None


class DeleteChannelResponse(BaseModel):
    channel: Optional[ChannelResponse] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class DeleteChannelsResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    result: Optional[Dict[str, DeleteChannelsResult]] = None
    task_id: Optional[str] = None


class DeleteUserResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    task_id: str
    user: Optional[UserObject] = None


class FileUploadRequest(BaseModel):
    file: Optional[str] = Field(None, description='file field', title='File')
    user: Optional[OnlyUserIDRequest] = Field(
        None, description='user for the request **server side only**', title='User'
    )


class FlagRequest(BaseModel):
    target_message_id: Optional[str] = Field(
        None,
        description='ID of the message when reporting a message',
        title='Target Message ID',
    )
    target_user_id: Optional[str] = Field(
        None, description='ID of the user when reporting a user', title='Target User ID'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class GetCallTokenRequest(BaseModel):
    user: Optional[UserObjectRequest] = Field(
        None,
        description='**Server-side only**. User object which server acts upon',
        title='User',
    )
    user_id: Optional[str] = Field(
        None,
        description='**Server-side only**. User ID which server acts upon',
        title='User ID',
    )


class GetCustomPermissionResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    permission: Permission


class GetOGResponse(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    actions: Optional[List[Action]] = None
    asset_url: Optional[str] = Field(
        None, description='URL of detected video or audio', title='Image URL'
    )
    author_icon: Optional[str] = None
    author_link: Optional[str] = Field(None, description='og:site', title='Author Link')
    author_name: Optional[str] = Field(
        None, description='og:site_name', title='Author Name'
    )
    color: Optional[str] = None
    duration: str
    fallback: Optional[str] = None
    fields: Optional[List[FieldModel]] = None
    footer: Optional[str] = None
    footer_icon: Optional[str] = None
    giphy: Optional[Images] = None
    image_url: Optional[str] = Field(
        None, description='URL of detected image', title='Image URL'
    )
    og_scrape_url: Optional[str] = Field(
        None, description='extracted url from the text', title='OG Scrape URL'
    )
    original_height: Optional[float] = None
    original_width: Optional[float] = None
    pretext: Optional[str] = None
    text: Optional[str] = Field(None, description='og:description', title='Text')
    thumb_url: Optional[str] = Field(
        None, description='URL of detected thumb image', title='Image URL'
    )
    title: Optional[str] = Field(None, description='og:title', title='Title')
    title_link: Optional[str] = Field(None, description='og:url', title='Title Link')
    type: Optional[str] = Field(
        None,
        description='Attachment type, could be empty, image, audio or video',
        title='Type',
    )


class GetRateLimitsResponse(BaseModel):
    android: Optional[Dict[str, LimitInfo]] = Field(
        None,
        description='Map of endpoint rate limits for the Android platform',
        title='Android',
    )
    duration: str
    ios: Optional[Dict[str, LimitInfo]] = Field(
        None,
        description='Map of endpoint rate limits for the iOS platform',
        title='iOS',
    )
    server_side: Optional[Dict[str, LimitInfo]] = Field(
        None,
        description='Map of endpoint rate limits for the server-side platform',
        title='Server-side',
    )
    web: Optional[Dict[str, LimitInfo]] = Field(
        None,
        description='Map of endpoint rate limits for the web platform',
        title='Web',
    )


class GuestRequest(BaseModel):
    user: UserObjectRequest


class GuestResponse(BaseModel):
    access_token: str = Field(
        ...,
        description='Authentication token to use for guest user',
        title='Access token',
    )
    duration: str
    user: Optional[UserObject] = Field(
        None, description='Created user object', title='User'
    )


class HideChannelRequest(BaseModel):
    clear_history: Optional[bool] = Field(
        None,
        description='Whether to clear message history of the channel or not',
        title='Clear history',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class ImageUploadRequest(BaseModel):
    file: Optional[str] = None
    upload_sizes: Optional[List[ImageSizeRequest]] = Field(
        None,
        description='field with JSON-encoded array of image size configurations',
        title='Upload sizes',
    )
    user: Optional[OnlyUserIDRequest] = None


class ImportTask(BaseModel):
    created_at: datetime
    history: List[ImportTaskHistory]
    id: str
    mode: str
    path: str
    result: Optional[Any] = None
    size: Optional[float] = None
    state: str
    updated_at: datetime


class ListChannelTypesResponse(BaseModel):
    channel_types: Dict[str, ChannelTypeConfig] = Field(
        ..., description='Object with all channel types', title='Channel types'
    )
    duration: str


class ListImportsResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    import_tasks: List[ImportTask]


class ListPermissionsResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    permissions: List[Permission]


class ListPushProvidersResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    push_providers: List[PushProviderModel]


class ListRolesResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    roles: List[RoleModel]


class MarkChannelsReadRequest(BaseModel):
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class MarkReadRequest(BaseModel):
    message_id: Optional[str] = Field(
        None,
        description='ID of the message that is considered last read by client',
        title='Message ID',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class MarkUnreadRequest(BaseModel):
    message_id: str = Field(
        ...,
        description='ID of the message from where the channel is marked unread',
        title='Message ID',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class MemberAddedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class MemberRemovedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    type: str
    user: Optional[UserObject] = None


class MemberUpdatedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class MembersResponse(BaseModel):
    duration: str
    members: List[ChannelMember] = Field(
        ..., description='List of found members', title='Members'
    )


class MessageActionRequest(BaseModel):
    ID: Optional[str] = None
    form_data: Dict[str, str] = Field(
        ..., description='Data to execute command with', title='Form data'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class MessageModerationResult(BaseModel):
    action: str
    ai_moderation_response: Optional[ModerationResponse] = None
    blocked_word: Optional[str] = None
    blocklist_name: Optional[str] = None
    created_at: datetime
    message_id: str
    moderated_by: Optional[str] = None
    moderation_thresholds: Optional[Thresholds] = None
    updated_at: datetime
    user_bad_karma: bool
    user_karma: float


class MessageReadEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class MessageRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    attachments: List[AttachmentRequest] = Field(
        ...,
        description='Array of message attachments',
        le=10,
        title='Message attachments',
    )
    cid: Optional[List[float]] = Field(
        None,
        description='Channel unique identifier in <type>:<id> format',
        title='Channel CID',
    )
    html: Optional[str] = Field(
        None,
        description='Contains HTML markup of the message. Can only be set when using server-side API',
        title='HTML content',
    )
    id: Optional[constr(max_length=255)] = Field(
        None,
        description='Message ID is unique string identifier of the message',
        title='ID',
    )
    mentioned_users: Optional[List[str]] = Field(
        None, description='List of mentioned users', le=25, title='Mentioned Users'
    )
    mml: Optional[str] = Field(
        None,
        description='Should be empty if `text` is provided. Can only be set when using server-side API',
        title='Messaging Markup Language',
    )
    parent: Optional[List[float]] = None
    parent_id: Optional[str] = Field(
        None, description='ID of parent message (thread)', title='Parent message ID'
    )
    pin_expires: Optional[datetime] = Field(
        None,
        description='Date when pinned message expires',
        title='Pin expiration date',
    )
    pinned: Optional[bool] = Field(
        None, description='Whether message is pinned or not', title='Pinned'
    )
    pinned_at: Optional[datetime] = Field(
        None, description='Date when message got pinned', title='Pinned at'
    )
    pinned_by: Optional[List[float]] = Field(
        None, description='Contains user who pinned the message', title='Pinned by'
    )
    quoted_message_id: Optional[str] = Field(None, title='ID of quoted message')
    reaction_scores: Optional[List[float]] = Field(
        None,
        description='An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int)',
        title='Reaction scores',
    )
    show_in_channel: Optional[bool] = Field(
        None,
        description='Whether thread reply should be shown in the channel as well',
        title='Show in channel',
    )
    silent: Optional[bool] = Field(
        None, description='Whether message is silent or not', title='Silent'
    )
    text: Optional[str] = Field(
        None,
        description='Text of the message. Should be empty if `mml` is provided',
        title='Text',
    )
    user: Optional[UserObjectRequest] = Field(
        None,
        description='Sender of the message. Required when using server-side API',
        title='User object',
    )
    user_id: Optional[str] = Field(None, title='User ID')


class MuteChannelRequest(BaseModel):
    channel_cids: List[str] = Field(
        ...,
        description='Channel CIDs to mute (if multiple channels)',
        le=25,
        title='Channel CIDs',
    )
    expiration: Optional[float] = Field(
        None, description='Duration of mute in milliseconds', title='Expiration'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class MuteUserRequest(BaseModel):
    target_ids: List[str] = Field(
        ...,
        description='User IDs to mute (if multiple users)',
        le=1000,
        title='Target IDs',
    )
    timeout: Optional[confloat(ge=0.0)] = Field(
        None, description='Duration of mute in minutes', title='Timeout'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class NotificationAddedToChannelEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    type: str


class NotificationChannelDeletedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    team: Optional[str] = None
    type: str


class NotificationChannelTruncatedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    type: str


class NotificationInviteAcceptedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    type: str
    user: Optional[UserObject] = None


class NotificationInviteRejectedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    type: str
    user: Optional[UserObject] = None


class NotificationInvitedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    type: str
    user: Optional[UserObject] = None


class NotificationMarkReadEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    team: Optional[str] = None
    total_unread_count: float
    type: str
    unread_channels: float
    unread_count: float
    user: Optional[UserObject] = None


class NotificationMarkUnreadEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    team: Optional[str] = None
    total_unread_count: float
    type: str
    unread_channels: float
    unread_count: float
    user: Optional[UserObject] = None


class NotificationRemovedFromChannelEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    member: Optional[ChannelMember] = None
    type: str
    user: Optional[UserObject] = None


class PushNotificationFields(BaseModel):
    apn: APNConfigFields
    firebase: FirebaseConfigFields
    huawei: HuaweiConfigFields
    offline_only: bool
    providers: Optional[List[PushProviderModel]] = None
    version: str
    xiaomi: XiaomiConfigFields


class QueryBannedUsersRequest(BaseModel):
    created_at_after: Optional[datetime] = None
    created_at_after_or_equal: Optional[datetime] = None
    created_at_before: Optional[datetime] = None
    created_at_before_or_equal: Optional[datetime] = None
    filter_conditions: Dict[str, Any]
    limit: Optional[confloat(le=300.0)] = None
    offset: Optional[confloat(le=10000.0)] = None
    sort: Optional[List[SortParam]] = Field(None, le=1)
    user: Optional[UserObject] = Field(
        None,
        description='**Server-side only**. User object which server acts upon',
        title='User',
    )
    user_id: Optional[str] = Field(
        None,
        description='**Server-side only**. User ID which server acts upon',
        title='User ID',
    )


class QueryCampaignsRequest(BaseModel):
    filter_conditions: Dict[str, Any]
    limit: Optional[confloat(ge=1.0, le=20.0)] = None
    sort: Optional[CampaignSort] = None


class QueryChannelsRequest(BaseModel):
    client_id: Optional[str] = None
    connection_id: Optional[str] = None
    filter_conditions: Optional[Dict[str, Any]] = None
    limit: Optional[float] = Field(
        None, description='Number of channels to limit', title='Limit'
    )
    member_limit: Optional[confloat(ge=0.0, le=100.0)] = Field(
        None, description='Number of members to limit', title='Member limit'
    )
    message_limit: Optional[confloat(ge=0.0)] = Field(
        None, description='Number of messages to limit', title='Message limit'
    )
    offset: Optional[float] = Field(
        None, description='Channel pagination offset', title='Offset'
    )
    presence: Optional[bool] = Field(None, title='Presence')
    sort: List[SortParamRequest] = Field(
        ..., description='List of sort parameters', le=5, title='Sort'
    )
    state: Optional[bool] = Field(
        None, description='Whether to update channel state or not', title='State'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None
    watch: Optional[bool] = Field(
        None,
        description='Whether to start watching found channels or not',
        title='Watch',
    )


class QueryMembersRequest(BaseModel):
    created_at_after: Optional[datetime] = None
    created_at_after_or_equal: Optional[datetime] = None
    created_at_before: Optional[datetime] = None
    created_at_before_or_equal: Optional[datetime] = None
    filter_conditions: Dict[str, Any] = Field(
        ..., description='Filter to apply to members', title='Filter conditions'
    )
    id: Optional[constr(max_length=64)] = Field(
        None, description='Channel ID to interact with', title='Channel ID'
    )
    limit: Optional[confloat(ge=0.0, le=300.0)] = Field(
        None, description='Number of records to return', title='Limit'
    )
    members: Optional[List[ChannelMember]] = Field(
        None,
        description='List of members to search in distinct channels',
        le=100,
        title='Members',
    )
    offset: Optional[confloat(le=10000.0)] = Field(
        None, description='Number of records to offset', title='Offset'
    )
    sort: Optional[List[SortParam]] = Field(
        None, description='Array of sort parameters', le=1, title='Sort'
    )
    type: constr(max_length=64) = Field(
        ..., description='Channel type to interact with', title='Channel type'
    )
    user: Optional[UserObject] = None
    user_id: Optional[str] = None
    user_id_gt: Optional[str] = None
    user_id_gte: Optional[str] = None
    user_id_lt: Optional[str] = None
    user_id_lte: Optional[str] = None


class QueryMessageFlagsRequest(BaseModel):
    filter_conditions: Optional[Dict[str, Any]] = None
    limit: Optional[confloat(ge=0.0, le=300.0)] = None
    offset: Optional[confloat(le=10000.0)] = None
    user: Optional[UserObject] = Field(
        None,
        description='**Server-side only**. User object which server acts upon',
        title='User',
    )
    user_id: Optional[str] = Field(
        None,
        description='**Server-side only**. User ID which server acts upon',
        title='User ID',
    )


class QueryRecipientsRequest(BaseModel):
    filter_conditions: Dict[str, Any]
    limit: Optional[confloat(ge=1.0, le=20.0)] = None
    sort: Optional[CampaignSort] = None


class QuerySegmentsRequest(BaseModel):
    filter_conditions: Dict[str, Any]
    limit: Optional[confloat(ge=1.0, le=20.0)] = None
    sort: Optional[CampaignSort] = None


class QuerySegmentsResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    segments: List[Segment]


class QueryUsersRequest(BaseModel):
    client_id: Optional[str] = None
    connection_id: Optional[str] = None
    filter_conditions: Dict[str, Any] = Field(
        ..., description='User filters', title='Filter conditions'
    )
    id_gt: Optional[str] = None
    id_gte: Optional[str] = None
    id_lt: Optional[str] = None
    id_lte: Optional[str] = None
    limit: Optional[confloat(ge=0.0, le=100.0)] = None
    offset: Optional[confloat(le=1000.0)] = None
    presence: Optional[bool] = Field(
        None, description='Request user presence status', title='Presence'
    )
    sort: List[SortParam] = Field(
        ..., description='Array of sort parameters', le=5, title='Sort'
    )
    user: Optional[UserObject] = None
    user_id: Optional[str] = None


class Reaction(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    message_id: str = Field(
        ..., description='ID of a message user reacted to', title='Message ID'
    )
    score: float = Field(
        ...,
        description='Reaction score. If not specified reaction has score of 1',
        title='Score',
    )
    type: constr(max_length=30) = Field(
        ...,
        description="The type of reaction (e.g. 'like', 'laugh', 'wow')",
        title='Type',
    )
    updated_at: datetime = Field(
        ..., description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObject] = None
    user_id: Optional[str] = Field(
        None, description='ID of a user who reacted to a message', title='User ID'
    )


class ReactionRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    message_id: Optional[str] = Field(
        None, description='ID of a message user reacted to', title='Message ID'
    )
    score: Optional[float] = Field(
        None,
        description='Reaction score. If not specified reaction has score of 1',
        title='Score',
    )
    type: constr(max_length=30) = Field(
        ...,
        description="The type of reaction (e.g. 'like', 'laugh', 'wow')",
        title='Type',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = Field(
        None, description='ID of a user who reacted to a message', title='User ID'
    )


class ReactivateUserResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    user: Optional[UserObject] = None


class Read(BaseModel):
    last_read: datetime
    unread_messages: float
    user: Optional[UserObject] = None


class ResumeCampaignResponse(BaseModel):
    campaign: Optional[Campaign] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class ScheduleCampaignResponse(BaseModel):
    campaign: Optional[Campaign] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class SearchRequest(BaseModel):
    filter_conditions: Dict[str, Any] = Field(
        ..., description='Channel filter conditions', title='Channel filter'
    )
    limit: Optional[float] = Field(
        None, description='Number of messages to return', title='Limit'
    )
    message_filter_conditions: Optional[Dict[str, Any]] = Field(
        None, description='Message filter conditions', title='Message filter'
    )
    next: Optional[str] = Field(
        None,
        description='Pagination parameter. Cannot be used with non-zero offset.',
        title='Next',
    )
    offset: Optional[float] = Field(
        None,
        description='Pagination offset. Cannot be used with sort or next.',
        title='Offset',
    )
    query: Optional[str] = Field(None, description='Search phrase', title='Query')
    sort: Optional[List[SortParam]] = Field(
        None,
        description='Sort parameters. Cannot be used with non-zero offset',
        title='Sort',
    )


class SendMessageRequest(BaseModel):
    force_moderation: Optional[bool] = Field(
        None,
        description='Enable moderation on server-side requests',
        title='Force moderation',
    )
    is_pending_message: Optional[bool] = Field(
        None,
        description='Make the message a pending message. This message will not be viewable to others until it is committed.',
        title='Is pending message',
    )
    message: MessageRequest
    pending_message_metadata: Optional[Dict[str, str]] = None
    skip_enrich_url: Optional[bool] = Field(
        None,
        description='Do not try to enrich the links within message',
        title='Skip Enrich URL',
    )
    skip_push: Optional[bool] = Field(
        None,
        description='Disables all push notifications for this message',
        title='Skip push notifications',
    )


class SendReactionRequest(BaseModel):
    ID: Optional[str] = None
    enforce_unique: Optional[bool] = Field(
        None,
        description='Whether to replace all existing user reactions',
        title='Enforce unique',
    )
    reaction: ReactionRequest
    skip_push: Optional[bool] = Field(
        None, description='Skips any mobile push notifications', title='Skip push'
    )


class SendUserCustomEventRequest(BaseModel):
    event: UserCustomEventRequest


class ShowChannelRequest(BaseModel):
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class StopCampaignResponse(BaseModel):
    campaign: Optional[Campaign] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class SyncRequest(BaseModel):
    channel_cids: Optional[List[str]] = Field(
        None,
        description='List of channel CIDs to sync',
        ge=1,
        le=255,
        title='Channel CIDs',
    )
    client_id: Optional[str] = None
    connection_id: Optional[str] = None
    last_sync_at: datetime = Field(
        ...,
        description='Date from which synchronization should happen',
        title='Last sync at',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None
    watch: Optional[bool] = Field(
        None,
        description='If set to true this will start watching requested and newly added channels that user has access to. If error occurred with this option enabled and it is not an input error - channels will still be watched.',
        title='Watch synced channels',
    )
    with_inaccessible_cids: Optional[bool] = Field(
        None,
        description="If set to true this will add 'inaccessible_cids' to response type",
        title='With inaccessible CIDs',
    )


class TruncateChannelRequest(BaseModel):
    hard_delete: Optional[bool] = Field(
        None,
        description='Permanently delete channel data (messages, reactions, etc.)',
        title='Hard delete',
    )
    message: Optional[MessageRequest] = None
    skip_push: Optional[bool] = Field(
        None,
        description='When `message` is set disables all push notifications for it',
        title='Skip push',
    )
    truncated_at: Optional[datetime] = Field(
        None,
        description='Truncate channel data up to `truncated_at`. The system message (if provided) creation time is always greater than `truncated_at`',
        title='Truncated at',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class TypingStartEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    parent_id: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class TypingStopEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    parent_id: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class UnmuteChannelRequest(BaseModel):
    channel_cid: str
    channel_cids: List[str] = Field(..., le=25)
    expiration: Optional[float] = None
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class UnmuteUserRequest(BaseModel):
    target_id: str
    target_ids: List[str] = Field(..., le=1000)
    timeout: Optional[confloat(ge=0.0)] = None
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class UpdateAppRequest(BaseModel):
    agora_options: Optional[ConfigRequest] = None
    apn_config: Optional[APNConfigRequest] = None
    async_moderation_config: Optional[AsyncModerationConfigurationRequest] = None
    async_url_enrich_enabled: Optional[bool] = None
    auto_translation_enabled: Optional[bool] = None
    before_message_send_hook_url: Optional[str] = None
    cdn_expiration_seconds: Optional[confloat(ge=14400.0, le=1209600.0)] = None
    channel_hide_members_only: Optional[bool] = None
    custom_action_handler_url: Optional[str] = None
    disable_auth_checks: Optional[bool] = None
    disable_permissions_checks: Optional[bool] = None
    enforce_unique_usernames: Optional[EnforceUniqueUsernames] = None
    file_upload_config: Optional[FileUploadConfigRequest] = None
    firebase_config: Optional[FirebaseConfigRequest] = None
    grants: Optional[Dict[str, List[str]]] = None
    hms_options: Optional[ConfigRequest] = None
    huawei_config: Optional[HuaweiConfigRequest] = None
    image_moderation_block_labels: Optional[List[str]] = None
    image_moderation_enabled: Optional[bool] = None
    image_moderation_labels: Optional[List[str]] = None
    image_upload_config: Optional[FileUploadConfigRequest] = None
    migrate_permissions_to_v2: Optional[bool] = None
    multi_tenant_enabled: Optional[bool] = None
    permission_version: Optional[PermissionVersion] = None
    push_config: Optional[PushConfigRequest] = None
    reminders_interval: Optional[confloat(ge=60.0, le=86400.0)] = None
    revoke_tokens_issued_before: Optional[datetime] = None
    sqs_key: Optional[str] = None
    sqs_secret: Optional[str] = None
    sqs_url: Optional[str] = None
    user_search_disallowed_roles: Optional[List[str]] = None
    video_provider: Optional[VideoProvider] = None
    webhook_events: Optional[List[str]] = None
    webhook_url: Optional[str] = None
    xiaomi_config: Optional[XiaomiConfigRequest] = None


class UpdateCampaignRequest(BaseModel):
    campaign: CampaignUpdateableFieldsRequest


class UpdateCampaignResponse(BaseModel):
    campaign: Optional[Campaign] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class UpdateChannelPartialRequest(BaseModel):
    set: Dict[str, Any]
    unset: List[str]
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class UpdateChannelPartialResponse(BaseModel):
    channel: Optional[ChannelResponse] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    members: List[ChannelMember]


class UpdateChannelRequest(BaseModel):
    accept_invite: Optional[bool] = Field(
        None, description='Set to `true` to accept the invite', title='Accept invite'
    )
    add_members: Optional[List[ChannelMemberRequest]] = Field(
        None,
        description='List of user IDs to add to the channel',
        le=100,
        title='Add members',
    )
    add_moderators: List[str] = Field(
        ...,
        description='List of user IDs to make channel moderators',
        le=100,
        title='Add moderators',
    )
    assign_roles: Optional[List[ChannelMemberRequest]] = Field(
        None,
        description='List of channel member role assignments. If any specified user is not part of the channel, the request will fail',
        le=100,
        title='Assign roles',
    )
    cooldown: Optional[confloat(ge=0.0, le=120.0)] = Field(
        None,
        description='Sets cool down period for the channel in seconds',
        title='Cool down',
    )
    data: Optional[ChannelRequest] = None
    demote_moderators: List[str] = Field(
        ...,
        description='List of user IDs to take away moderators status from',
        le=100,
        title='Demote moderators',
    )
    hide_history: Optional[bool] = Field(
        None,
        description="Set to `true` to hide channel's history when adding new members",
        title='Hide history',
    )
    invites: Optional[List[ChannelMemberRequest]] = Field(
        None,
        description='List of user IDs to invite to the channel',
        le=100,
        title='Invites',
    )
    message: Optional[MessageRequest] = Field(
        None,
        description='Message to send to the chat when channel is successfully updated',
        title='Message',
    )
    reject_invite: Optional[bool] = Field(
        None, description='Set to `true` to reject the invite', title='Reject invite'
    )
    remove_members: List[str] = Field(
        ...,
        description='List of user IDs to remove from the channel',
        le=100,
        title='Remove members',
    )
    skip_push: Optional[bool] = Field(
        None,
        description='When `message` is set disables all push notifications for it',
        title='Skip push',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class UpdateMessagePartialRequest(BaseModel):
    set: Dict[str, Any] = Field(..., description='Sets new field values', title='Set')
    skip_enrich_url: Optional[bool] = Field(
        None,
        description='Do not try to enrich the links within message',
        title='Skip Enrich URL',
    )
    unset: List[str] = Field(
        ..., description='Array of field names to unset', title='Unset'
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = None


class UpdateMessageRequest(BaseModel):
    message: MessageRequest
    pending_message_metadata: Optional[Dict[str, str]] = None
    skip_enrich_url: Optional[bool] = Field(
        None,
        description='Do not try to enrich the links within message',
        title='Skip Enrich URL',
    )


class UpdateUsersRequest(BaseModel):
    users: Dict[str, UserObjectRequest] = Field(
        ..., description='Object containing users', title='Users'
    )


class UpdateUsersResponse(BaseModel):
    duration: str
    users: Dict[str, UserObject] = Field(
        ..., description='Object containing users', title='Users'
    )


class UserBannedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    created_by: UserObject
    expiration: Optional[datetime] = None
    reason: Optional[str] = None
    shadow: bool
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class UserDeactivatedEvent(BaseModel):
    created_at: datetime
    created_by: UserObject
    type: str
    user: Optional[UserObject] = None


class UserDeletedEvent(BaseModel):
    created_at: datetime
    delete_conversation_channels: bool
    hard_delete: bool
    mark_messages_deleted: bool
    type: str
    user: Optional[UserObject] = None


class UserFlaggedEvent(BaseModel):
    created_at: datetime
    target_user: Optional[str] = None
    target_users: Optional[List[str]] = None
    type: str
    user: Optional[UserObject] = None


class UserMute(BaseModel):
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    expires: Optional[datetime] = Field(
        None, description='Date/time of mute expiration', title='Expires'
    )
    target: Optional[UserObject] = Field(
        None, description="User who's muted", title='Target'
    )
    updated_at: datetime = Field(
        ..., description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObject] = Field(
        None, description='Owner of channel mute', title='User'
    )


class UserMuteRequest(BaseModel):
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    expires: Optional[datetime] = Field(
        None, description='Date/time of mute expiration', title='Expires'
    )
    target: Optional[UserObjectRequest] = Field(
        None, description="User who's muted", title='Target'
    )
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObjectRequest] = Field(
        None, description='Owner of channel mute', title='User'
    )


class UserMutedEvent(BaseModel):
    created_at: datetime
    target_user: Optional[str] = None
    target_users: Optional[List[str]] = None
    type: str
    user: Optional[UserObject] = None


class Payload(BaseModel):
    filter_conditions: Dict[str, Any]
    limit: Optional[confloat(ge=1.0, le=20.0)] = None
    sort: Optional[CampaignSort] = None


class Payload1(BaseModel):
    created_at_after: Optional[datetime] = None
    created_at_after_or_equal: Optional[datetime] = None
    created_at_before: Optional[datetime] = None
    created_at_before_or_equal: Optional[datetime] = None
    filter_conditions: Dict[str, Any] = Field(
        ..., description='Filter to apply to members', title='Filter conditions'
    )
    id: Optional[constr(max_length=64)] = Field(
        None, description='Channel ID to interact with', title='Channel ID'
    )
    limit: Optional[confloat(ge=0.0, le=300.0)] = Field(
        None, description='Number of records to return', title='Limit'
    )
    members: Optional[List[ChannelMember]] = Field(
        None,
        description='List of members to search in distinct channels',
        le=100,
        title='Members',
    )
    offset: Optional[confloat(le=10000.0)] = Field(
        None, description='Number of records to offset', title='Offset'
    )
    sort: Optional[List[SortParam]] = Field(
        None, description='Array of sort parameters', le=1, title='Sort'
    )
    type: constr(max_length=64) = Field(
        ..., description='Channel type to interact with', title='Channel type'
    )
    user: Optional[UserObject] = None
    user_id: Optional[str] = None
    user_id_gt: Optional[str] = None
    user_id_gte: Optional[str] = None
    user_id_lt: Optional[str] = None
    user_id_lte: Optional[str] = None


class Payload4(BaseModel):
    filter_conditions: Dict[str, Any]
    limit: Optional[confloat(ge=1.0, le=20.0)] = None
    sort: Optional[CampaignSort] = None


class App(BaseModel):
    agora_options: Optional[Config] = None
    async_url_enrich_enabled: bool
    auto_translation_enabled: Optional[bool] = None
    before_message_send_hook_url: Optional[str] = None
    campaign_enabled: bool
    cdn_expiration_seconds: float
    channel_configs: Dict[str, ChannelConfig] = Field(
        ..., description='Object with channel configs', title='Channel configs'
    )
    custom_action_handler_url: str
    disable_auth_checks: bool
    disable_permissions_checks: bool
    enforce_unique_usernames: str
    file_upload_config: FileUploadConfig
    grants: Dict[str, List[str]]
    hms_options: Optional[Config] = None
    image_moderation_enabled: bool
    image_moderation_labels: Optional[List[str]] = None
    image_upload_config: FileUploadConfig
    multi_tenant_enabled: bool
    name: str
    organization: str
    permission_version: str
    policies: Dict[str, List[Policy]]
    push_notifications: PushNotificationFields
    reminders_interval: float
    revoke_tokens_issued_before: Optional[datetime] = None
    search_backend: SearchBackend = Field(
        ...,
        description='Backend implementation used for search',
        title='Search Backend',
    )
    sqs_key: str
    sqs_secret: str
    sqs_url: str
    suspended: bool
    suspended_explanation: str
    user_search_disallowed_roles: List[str]
    video_provider: str
    webhook_events: List[str]
    webhook_url: str


class AutomodDetails(BaseModel):
    action: Optional[str] = None
    image_labels: Optional[List[str]] = None
    message_details: Optional[FlagMessageDetails] = None
    original_message_type: Optional[str] = None
    result: Optional[MessageModerationResult] = None


class BanResponse(BaseModel):
    banned_by: Optional[UserObject] = None
    channel: Optional[ChannelResponse] = None
    created_at: datetime
    expires: Optional[datetime] = None
    reason: Optional[str] = None
    shadow: Optional[bool] = None
    user: Optional[UserObject] = None


class Channel(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    auto_translation_enabled: Optional[bool] = None
    auto_translation_language: str
    cid: str
    config: Optional[ChannelConfig] = None
    config_overrides: Optional[ChannelConfig] = None
    cooldown: Optional[float] = None
    created_at: datetime
    created_by: Optional[UserObject] = None
    deleted_at: Optional[datetime] = None
    disabled: bool
    frozen: bool
    id: str
    invites: Optional[List[ChannelMember]] = None
    last_message_at: Optional[datetime] = None
    member_count: Optional[float] = None
    members: Optional[List[ChannelMember]] = None
    team: Optional[str] = None
    truncated_by: Optional[UserObject] = None
    type: str
    updated_at: datetime


class ChannelDeletedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    team: Optional[str] = None
    type: str


class ChannelGetOrCreateRequest(BaseModel):
    client_id: Optional[str] = None
    connection_id: Optional[str] = None
    data: Optional[ChannelRequest] = None
    members: Optional[PaginationParamsRequest] = None
    messages: Optional[MessagePaginationParamsRequest] = None
    presence: Optional[bool] = Field(
        None, description='Fetch user presence info', title='Presence'
    )
    state: Optional[bool] = Field(
        None, description='Refresh channel state', title='State'
    )
    watch: Optional[bool] = Field(
        None, description='Start watching the channel', title='Watch'
    )
    watchers: Optional[PaginationParamsRequest] = None


class ChannelHiddenEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    clear_history: bool
    created_at: datetime
    type: str
    user: Optional[UserObject] = None


class ChannelKickedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    type: str


class ChannelMute(BaseModel):
    channel: Optional[ChannelResponse] = None
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    expires: Optional[datetime] = Field(
        None, description='Date/time of mute expiration', title='Expires'
    )
    updated_at: datetime = Field(
        ..., description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObject] = Field(
        None, description='Owner of channel mute', title='User'
    )


class ChannelMuteRequest(BaseModel):
    channel: Optional[ChannelResponseRequest] = None
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    expires: Optional[datetime] = Field(
        None, description='Date/time of mute expiration', title='Expires'
    )
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObjectRequest] = Field(
        None, description='Owner of channel mute', title='User'
    )


class CreateImportResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    import_task: Optional[ImportTask] = None


class FlagDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    automod: Optional[AutomodDetails] = None


class GetApplicationResponse(BaseModel):
    app: App
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class GetImportResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    import_task: Optional[ImportTask] = None


class GetReactionsResponse(BaseModel):
    duration: str
    reactions: List[Reaction] = Field(
        ..., description='List of reactions', title='Reactions'
    )


class Message(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    attachments: List[Attachment] = Field(
        ..., description='Array of message attachments', title='Message attachments'
    )
    before_message_send_failed: Optional[bool] = Field(
        None,
        description='Whether `before_message_send webhook` failed or not. Field is only accessible in push webhook',
        title='Before Message Send Failed',
    )
    cid: str = Field(
        ...,
        description='Channel unique identifier in <type>:<id> format',
        title='Channel CID',
    )
    command: Optional[str] = Field(
        None, description='Contains provided slash command', title='Command'
    )
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    deleted_at: Optional[datetime] = Field(
        None, description='Date/time of deletion', title='Deleted at'
    )
    html: str = Field(
        ...,
        description='Contains HTML markup of the message. Can only be set when using server-side API',
        title='HTML content',
    )
    i18n: Optional[Dict[str, str]] = Field(
        None,
        description='Object with translations. Key `language` contains the original language key. Other keys contain translations',
        title='Internationalization info',
    )
    id: str = Field(
        ...,
        description='Message ID is unique string identifier of the message',
        title='ID',
    )
    image_labels: Optional[Dict[str, List[str]]] = Field(
        None,
        description='Contains image moderation information',
        title='Image moderation labels',
    )
    latest_reactions: List[Reaction] = Field(
        ...,
        description='List of 10 latest reactions to this message',
        title='Latest reactions',
    )
    mentioned_users: List[UserObject] = Field(
        ..., description='List of mentioned users', title='Mentioned Users'
    )
    mml: Optional[str] = Field(
        None,
        description='Should be empty if `text` is provided. Can only be set when using server-side API',
        title='Messaging Markup Language',
    )
    own_reactions: List[Reaction] = Field(
        ...,
        description='List of 10 latest reactions of authenticated user to this message',
        title='Own reactions',
    )
    parent_id: Optional[str] = Field(
        None, description='ID of parent message (thread)', title='Parent message ID'
    )
    pin_expires: Optional[datetime] = Field(
        None,
        description='Date when pinned message expires',
        title='Pin expiration date',
    )
    pinned: bool = Field(
        ..., description='Whether message is pinned or not', title='Pinned'
    )
    pinned_at: Optional[datetime] = Field(
        None, description='Date when message got pinned', title='Pinned at'
    )
    pinned_by: Optional[UserObject] = Field(
        None, description='Contains user who pinned the message', title='Pinned by'
    )
    quoted_message: Optional[Message] = Field(
        None, description='Contains quoted message', title='Quoted message'
    )
    quoted_message_id: Optional[str] = Field(None, title='ID of quoted message')
    reaction_counts: Dict[str, float] = Field(
        ...,
        description='An object containing number of reactions of each type. Key: reaction type (string), value: number of reactions (int)',
        title='Reaction counts',
    )
    reaction_scores: Dict[str, float] = Field(
        ...,
        description='An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int)',
        title='Reaction scores',
    )
    reply_count: float = Field(
        ..., description='Number of replies to this message', title='Reply count'
    )
    shadowed: bool = Field(
        ..., description='Whether the message was shadowed or not', title='Shadowed'
    )
    show_in_channel: Optional[bool] = Field(
        None,
        description='Whether thread reply should be shown in the channel as well',
        title='Show in channel',
    )
    silent: bool = Field(
        ..., description='Whether message is silent or not', title='Silent'
    )
    text: str = Field(
        ...,
        description='Text of the message. Should be empty if `mml` is provided',
        title='Text',
    )
    thread_participants: Optional[List[UserObject]] = Field(
        None,
        description='List of users who participate in thread',
        title='Thread participants',
    )
    type: Type1 = Field(
        ..., description='Contains type of the message', title='Message Type'
    )
    updated_at: datetime = Field(
        ..., description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObject] = Field(
        None,
        description='Sender of the message. Required when using server-side API',
        title='User object',
    )


class MessageDeletedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    hard_delete: bool
    message: Optional[Message] = None
    team: Optional[str] = None
    thread_participants: Optional[List[UserObject]] = None
    type: str
    user: Optional[UserObject] = None


class MessageFlag(BaseModel):
    approved_at: Optional[datetime] = None
    created_at: datetime
    created_by_automod: bool
    message: Optional[Message] = None
    moderation_result: Optional[MessageModerationResult] = None
    rejected_at: Optional[datetime] = None
    reviewed_at: Optional[datetime] = None
    reviewed_by: Optional[UserObject] = None
    updated_at: datetime
    user: Optional[UserObject] = None


class MessageNewEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    message: Optional[Message] = None
    team: Optional[str] = None
    thread_participants: Optional[List[UserObject]] = None
    type: str
    user: Optional[UserObject] = None
    watcher_count: float


class MessageRequest1(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    attachments: Optional[List[AttachmentRequest]] = Field(
        None, description='Array of message attachments', title='Message attachments'
    )
    before_message_send_failed: Optional[bool] = Field(
        None,
        description='Whether `before_message_send webhook` failed or not. Field is only accessible in push webhook',
        title='Before Message Send Failed',
    )
    cid: Optional[str] = Field(
        None,
        description='Channel unique identifier in <type>:<id> format',
        title='Channel CID',
    )
    command: Optional[str] = Field(
        None, description='Contains provided slash command', title='Command'
    )
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    deleted_at: Optional[datetime] = Field(
        None, description='Date/time of deletion', title='Deleted at'
    )
    html: Optional[str] = Field(
        None,
        description='Contains HTML markup of the message. Can only be set when using server-side API',
        title='HTML content',
    )
    i18n: Optional[Dict[str, str]] = Field(
        None,
        description='Object with translations. Key `language` contains the original language key. Other keys contain translations',
        title='Internationalization info',
    )
    id: Optional[str] = Field(
        None,
        description='Message ID is unique string identifier of the message',
        title='ID',
    )
    image_labels: Optional[Dict[str, List[str]]] = Field(
        None,
        description='Contains image moderation information',
        title='Image moderation labels',
    )
    latest_reactions: Optional[List[ReactionRequest]] = Field(
        None,
        description='List of 10 latest reactions to this message',
        title='Latest reactions',
    )
    mentioned_users: Optional[List[UserObjectRequest]] = Field(
        None, description='List of mentioned users', title='Mentioned Users'
    )
    mml: str = Field(
        ...,
        description='Should be empty if `text` is provided. Can only be set when using server-side API',
        title='Messaging Markup Language',
    )
    own_reactions: Optional[List[ReactionRequest]] = Field(
        None,
        description='List of 10 latest reactions of authenticated user to this message',
        title='Own reactions',
    )
    parent_id: Optional[str] = Field(
        None, description='ID of parent message (thread)', title='Parent message ID'
    )
    pin_expires: Optional[datetime] = Field(
        None,
        description='Date when pinned message expires',
        title='Pin expiration date',
    )
    pinned: Optional[bool] = Field(
        None, description='Whether message is pinned or not', title='Pinned'
    )
    pinned_at: Optional[datetime] = Field(
        None, description='Date when message got pinned', title='Pinned at'
    )
    pinned_by: Optional[UserObjectRequest] = Field(
        None, description='Contains user who pinned the message', title='Pinned by'
    )
    quoted_message: Optional[MessageRequest1] = Field(
        None, description='Contains quoted message', title='Quoted message'
    )
    quoted_message_id: Optional[str] = Field(None, title='ID of quoted message')
    reaction_counts: Optional[Dict[str, float]] = Field(
        None,
        description='An object containing number of reactions of each type. Key: reaction type (string), value: number of reactions (int)',
        title='Reaction counts',
    )
    reaction_scores: Optional[Dict[str, float]] = Field(
        None,
        description='An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int)',
        title='Reaction scores',
    )
    reply_count: Optional[float] = Field(
        None, description='Number of replies to this message', title='Reply count'
    )
    shadowed: Optional[bool] = Field(
        None, description='Whether the message was shadowed or not', title='Shadowed'
    )
    show_in_channel: Optional[bool] = Field(
        None,
        description='Whether thread reply should be shown in the channel as well',
        title='Show in channel',
    )
    silent: Optional[bool] = Field(
        None, description='Whether message is silent or not', title='Silent'
    )
    text: str = Field(
        ...,
        description='Text of the message. Should be empty if `mml` is provided',
        title='Text',
    )
    thread_participants: Optional[List[UserObjectRequest]] = Field(
        None,
        description='List of users who participate in thread',
        title='Thread participants',
    )
    type: Optional[Type1] = Field(
        None, description='Contains type of the message', title='Message Type'
    )
    updated_at: Optional[datetime] = Field(
        None, description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObjectRequest] = Field(
        None,
        description='Sender of the message. Required when using server-side API',
        title='User object',
    )


class MessageResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    message: Optional[Message] = None


class MessageUnblockedEvent(BaseModel):
    cid: str
    created_at: datetime
    message: Optional[Message] = None
    thread_participants: Optional[List[UserObject]] = None
    type: str
    user: Optional[UserObject] = None


class MessageUpdatedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    message: Optional[Message] = None
    team: Optional[str] = None
    thread_participants: Optional[List[UserObject]] = None
    type: str
    user: Optional[UserObject] = None


class MessageWithPendingMetadataResponse(BaseModel):
    duration: str
    message: Optional[Message] = None
    pending_message_metadata: Optional[Dict[str, str]] = Field(
        None,
        description='Metadata attached to a message while it is pending',
        title='Pending message metadata',
    )


class NotificationNewMessageEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    message: Message
    team: Optional[str] = None
    type: str


class OwnUser(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    banned: bool
    channel_mutes: List[ChannelMute]
    created_at: datetime
    deactivated_at: Optional[datetime] = None
    deleted_at: Optional[datetime] = None
    devices: List[Device]
    id: str
    invisible: Optional[bool] = None
    language: str
    last_active: Optional[datetime] = None
    latest_hidden_channels: Optional[List[str]] = None
    mutes: List[UserMute]
    online: bool
    push_notifications: Optional[PushNotificationSettings] = None
    role: str
    teams: Optional[List[str]] = None
    total_unread_count: float
    unread_channels: float
    unread_count: float
    updated_at: datetime


class OwnUserRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    banned: Optional[bool] = None
    channel_mutes: Optional[List[ChannelMuteRequest]] = None
    created_at: Optional[datetime] = None
    deactivated_at: Optional[datetime] = None
    deleted_at: Optional[datetime] = None
    devices: Optional[List[DeviceRequest]] = None
    id: Optional[str] = None
    invisible: Optional[bool] = None
    language: Optional[str] = None
    last_active: Optional[datetime] = None
    latest_hidden_channels: Optional[List[str]] = None
    mutes: Optional[List[UserMuteRequest]] = None
    online: Optional[bool] = None
    push_notifications: Optional[PushNotificationSettingsRequest] = None
    role: Optional[str] = None
    teams: Optional[List[str]] = None
    total_unread_count: Optional[float] = None
    unread_channels: Optional[float] = None
    unread_count: Optional[float] = None
    updated_at: Optional[datetime] = None


class PendingMessage(BaseModel):
    channel: Optional[Channel] = None
    message: Optional[Message] = Field(None, description='The message', title='Message')
    metadata: Optional[Dict[str, str]] = Field(
        None,
        description='Additional data attached to the pending message. This data is discarded once the pending message is committed.',
        title='Metadata',
    )
    user: Optional[UserObject] = None


class QueryBannedUsersResponse(BaseModel):
    bans: List[BanResponse]
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )


class QueryCampaignsResponse(BaseModel):
    campaigns: List[Campaign]
    channels: Dict[str, Channel]
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    segments: Dict[str, Segment]
    users: Dict[str, UserObject]


class QueryMessageFlagsResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    flags: List[MessageFlag]


class QueryRecipientsResponse(BaseModel):
    campaigns: Dict[str, Campaign]
    channels: Dict[str, Channel]
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    recipients: List[Recipient]
    segments: Dict[str, Segment]
    users: Dict[str, UserObject]


class ReactionDeletedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    message: Optional[Message] = None
    reaction: Optional[Reaction] = None
    team: Optional[str] = None
    thread_participants: Optional[List[UserObject]] = None
    type: str
    user: Optional[UserObject] = None


class ReactionNewEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    message: Optional[Message] = None
    reaction: Optional[Reaction] = None
    team: Optional[str] = None
    thread_participants: Optional[List[UserObject]] = None
    type: str
    user: Optional[UserObject] = None


class ReactionRemovalResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    message: Optional[Message] = None
    reaction: Optional[Reaction] = None


class ReactionResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    message: Optional[Message] = None
    reaction: Optional[Reaction] = None


class ReactionUpdatedEvent(BaseModel):
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    message: Message
    reaction: Reaction
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class SearchResultMessage(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    attachments: List[Attachment]
    before_message_send_failed: Optional[bool] = None
    channel: Optional[ChannelResponse] = Field(
        None, description='Channel object', title='Channel'
    )
    cid: str
    command: Optional[str] = None
    created_at: datetime
    deleted_at: Optional[datetime] = None
    html: str
    i18n: Optional[Dict[str, str]] = None
    id: str
    image_labels: Optional[Dict[str, List[str]]] = None
    latest_reactions: List[Reaction]
    mentioned_users: List[UserObject]
    mml: Optional[str] = None
    own_reactions: List[Reaction]
    parent_id: Optional[str] = None
    pin_expires: Optional[datetime] = None
    pinned: bool
    pinned_at: Optional[datetime] = None
    pinned_by: Optional[UserObject] = None
    quoted_message: Optional[Message] = None
    quoted_message_id: Optional[str] = None
    reaction_counts: Dict[str, float]
    reaction_scores: Dict[str, float]
    reply_count: float
    shadowed: bool
    show_in_channel: Optional[bool] = None
    silent: bool
    text: str
    thread_participants: Optional[List[UserObject]] = None
    type: str
    updated_at: datetime
    user: Optional[UserObject] = None


class TruncateChannelResponse(BaseModel):
    channel: Optional[ChannelResponse] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    message: Optional[Message] = None


class UpdateChannelResponse(BaseModel):
    channel: Optional[ChannelResponse] = None
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    members: List[ChannelMember]
    message: Optional[Message] = None


class ChannelMessages(BaseModel):
    channel: Optional[ChannelResponse] = None
    messages: List[Message]


class ChannelStateResponse(BaseModel):
    channel: Optional[ChannelResponse] = None
    duration: str
    hidden: Optional[bool] = None
    hide_messages_before: Optional[datetime] = None
    members: List[ChannelMember]
    membership: Optional[ChannelMember] = None
    messages: List[Message]
    pending_messages: Optional[List[PendingMessage]] = None
    pinned_messages: List[Message]
    read: Optional[List[Read]] = None
    watcher_count: Optional[float] = None
    watchers: Optional[List[UserObject]] = None


class ChannelStateResponseFields(BaseModel):
    channel: Optional[ChannelResponse] = None
    hidden: Optional[bool] = Field(
        None, description='Whether this channel is hidden or not', title='Hidden'
    )
    hide_messages_before: Optional[datetime] = Field(
        None,
        description='Messages before this date are hidden from the user',
        title='Hide messages before',
    )
    members: List[ChannelMember] = Field(
        ..., description='List of channel members', title='Members'
    )
    membership: Optional[ChannelMember] = Field(
        None, description='Current user membership object', title='Membership'
    )
    messages: List[Message] = Field(
        ..., description='List of channel messages', title='Message'
    )
    pending_messages: Optional[List[PendingMessage]] = Field(
        None,
        description='Pending messages that this user has sent',
        title='Pending messages',
    )
    pinned_messages: List[Message] = Field(
        ...,
        description='List of pinned messages in the channel',
        title='Pinned messages',
    )
    read: Optional[List[Read]] = Field(
        None, description='List of read states', title='Read'
    )
    watcher_count: Optional[float] = Field(
        None, description='Number of channel watchers', title='Watcher count'
    )
    watchers: Optional[List[UserObject]] = Field(
        None, description='List of user who is watching the channel', title='Watchers'
    )


class ChannelUpdatedEvent(BaseModel):
    channel: Optional[ChannelResponse] = None
    channel_id: str
    channel_type: str
    cid: str
    created_at: datetime
    message: Optional[Message] = None
    team: Optional[str] = None
    type: str
    user: Optional[UserObject] = None


class ChannelsResponse(BaseModel):
    channels: List[ChannelStateResponseFields] = Field(
        ..., description='List of channels', title='Channels'
    )
    duration: str


class Event(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    automoderation: Optional[bool] = Field(
        None,
        description='Only applicable to `message.flagged` BaseEvent.',
        title='Auto moderation',
    )
    automoderation_scores: Optional[ModerationResponse] = Field(
        None,
        description='Only applicable to `message.flagged` BaseEvent.',
        title='Auto moderation scores',
    )
    channel: Optional[ChannelResponse] = None
    channel_id: Optional[str] = Field(None, title='Channel ID')
    channel_type: Optional[str] = Field(None, title='Channel type')
    cid: Optional[str] = Field(
        None, description='Channel CID (<type>:<id>)', title='CID'
    )
    connection_id: Optional[str] = Field(
        None,
        description='Only applicable to `health.check` BaseEvent',
        title='Connection ID',
    )
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    created_by: Optional[UserObject] = Field(
        None,
        description='User who issued moderation action. Only applicable to moderation-related events',
        title='Created by',
    )
    me: Optional[OwnUser] = None
    member: Optional[ChannelMember] = None
    message: Optional[Message] = None
    parent_id: Optional[str] = Field(
        None, description='ID of thread. Used in typing events', title='Parent ID'
    )
    reaction: Optional[Reaction] = None
    reason: Optional[str] = Field(
        None,
        description='Ban reason. Only applicable to `user.banned` BaseEvent',
        title='Reason',
    )
    team: Optional[str] = None
    type: str = Field(
        ...,
        description='Event type. To use custom BaseEvent types see Custom Events documentation',
        title='Type',
    )
    user: Optional[UserObject] = None
    user_id: Optional[str] = Field(None, title='User ID')
    watcher_count: Optional[float] = Field(
        None,
        description='Number of watchers who received this BaseEvent',
        title='Watcher count',
    )


class EventRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    automoderation: Optional[bool] = Field(
        None,
        description='Only applicable to `message.flagged` BaseEvent.',
        title='Auto moderation',
    )
    automoderation_scores: Optional[ModerationResponseRequest] = Field(
        None,
        description='Only applicable to `message.flagged` BaseEvent.',
        title='Auto moderation scores',
    )
    channel: Optional[ChannelResponseRequest] = None
    channel_id: Optional[str] = Field(None, title='Channel ID')
    channel_type: Optional[str] = Field(None, title='Channel type')
    cid: Optional[str] = Field(
        None, description='Channel CID (<type>:<id>)', title='CID'
    )
    connection_id: Optional[str] = Field(
        None,
        description='Only applicable to `health.check` BaseEvent',
        title='Connection ID',
    )
    created_at: Optional[datetime] = Field(
        None, description='Date/time of creation', title='Created at'
    )
    created_by: Optional[UserObjectRequest] = Field(
        None,
        description='User who issued moderation action. Only applicable to moderation-related events',
        title='Created by',
    )
    me: Optional[OwnUserRequest] = None
    member: Optional[ChannelMemberRequest] = None
    message: Optional[MessageRequest1] = None
    parent_id: Optional[str] = Field(
        None, description='ID of thread. Used in typing events', title='Parent ID'
    )
    reaction: Optional[ReactionRequest] = None
    reason: Optional[str] = Field(
        None,
        description='Ban reason. Only applicable to `user.banned` BaseEvent',
        title='Reason',
    )
    team: Optional[str] = None
    type: str = Field(
        ...,
        description='Event type. To use custom BaseEvent types see Custom Events documentation',
        title='Type',
    )
    user: Optional[UserObjectRequest] = None
    user_id: Optional[str] = Field(None, title='User ID')
    watcher_count: Optional[float] = Field(
        None,
        description='Number of watchers who received this BaseEvent',
        title='Watcher count',
    )


class EventResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    event: Optional[Event] = None


class ExportUserResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    messages: Optional[List[Message]] = None
    reactions: Optional[List[Reaction]] = None
    user: Optional[UserObject] = None


class Flag(BaseModel):
    approved_at: Optional[datetime] = Field(
        None, description='Date of the approval', title='Approved at'
    )
    created_at: datetime = Field(
        ..., description='Date/time of creation', title='Created at'
    )
    created_by_automod: bool
    details: Optional[FlagDetails] = None
    rejected_at: Optional[datetime] = Field(
        None, description='Date of the rejection', title='Rejected at'
    )
    reviewed_at: Optional[datetime] = Field(
        None, description='Date of the review', title='Reviewed at'
    )
    target_message: Optional[Message] = None
    target_message_id: Optional[str] = Field(
        None, description='ID of flagged message', title='Target Message ID'
    )
    target_user: Optional[UserObject] = Field(
        None, description='Flagged user', title='User'
    )
    updated_at: datetime = Field(
        ..., description='Date/time of the last update', title='Updated at'
    )
    user: Optional[UserObject] = Field(
        None, description='User who flagged a message or a user', title='User'
    )


class FlagResponse(BaseModel):
    duration: str = Field(
        ...,
        description='Duration of the request in human-readable format',
        title='Duration',
    )
    flag: Optional[Flag] = None


class GetManyMessagesResponse(BaseModel):
    duration: str
    messages: List[Message] = Field(
        ..., description='List of messages', title='Messages'
    )


class GetRepliesResponse(BaseModel):
    duration: str
    messages: List[Message] = Field(
        ..., description='List of messages', title='Messages'
    )


class HealthCheckEvent(BaseModel):
    cid: str
    created_at: datetime
    me: Optional[OwnUser] = None
    type: str


class MarkReadResponse(BaseModel):
    duration: str
    event: Optional[Event] = Field(None, description='Mark read event', title='Event')


class MessageFlaggedEvent(BaseModel):
    cid: str
    created_at: datetime
    flag: Optional[Flag] = None
    message: Optional[Message] = None
    thread_participants: Optional[List[UserObject]] = None
    type: str
    user: Optional[UserObject] = None


class MuteChannelResponse(BaseModel):
    channel_mute: Optional[ChannelMute] = Field(
        None,
        description='Object with channel mute (if one channel was muted)',
        title='Channel mute',
    )
    channel_mutes: Optional[List[ChannelMute]] = Field(
        None,
        description='Object with mutes (if multiple channels were muted)',
        title='Channel mutes',
    )
    duration: str
    own_user: Optional[OwnUser] = Field(
        None,
        description='Authorized user object with fresh mutes information',
        title='Own user',
    )


class MuteUserResponse(BaseModel):
    duration: str
    mute: Optional[UserMute] = Field(
        None, description='Object with user mute (if one user was muted)', title='Mute'
    )
    mutes: Optional[List[UserMute]] = Field(
        None,
        description='Object with mutes (if multiple users were muted)',
        title='Mutes',
    )
    own_user: Optional[OwnUser] = Field(
        None,
        description='Authorized user object with fresh mutes information',
        title='Own user',
    )


class NotificationChannelMutesUpdatedEvent(BaseModel):
    created_at: datetime
    me: OwnUser
    type: str


class NotificationMutesUpdatedEvent(BaseModel):
    created_at: datetime
    me: OwnUser
    type: str


class SearchResult(BaseModel):
    message: Optional[SearchResultMessage] = Field(
        None, description='Found message', title='Message'
    )


class SendEventRequest(BaseModel):
    event: EventRequest


class SyncResponse(BaseModel):
    duration: str
    events: List[Event] = Field(..., description='List of events', title='Events')
    inaccessible_cids: Optional[List[str]] = Field(
        None,
        description="List of CIDs that user can't access",
        title='Inaccessible CIDs',
    )


class UserUnreadReminderEvent(BaseModel):
    channels: Dict[str, ChannelMessages]
    created_at: datetime
    type: str
    user: Optional[UserObject] = None


class SearchResponse(BaseModel):
    duration: str
    next: Optional[str] = Field(
        None,
        description='Value to pass to the next search query in order to paginate',
        title='Next',
    )
    previous: Optional[str] = Field(
        None,
        description='Value that points to the previous page. Pass as the next value in a search query to paginate backwards',
        title='Previous',
    )
    results: List[SearchResult] = Field(
        ..., description='Search results', title='Results'
    )
    results_warning: Optional[SearchWarning] = Field(
        None, description='Warning about the search results', title='Results Warning'
    )


Message.model_rebuild()
MessageRequest1.model_rebuild()
